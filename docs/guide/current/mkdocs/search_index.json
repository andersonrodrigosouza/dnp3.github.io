{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nWelcome to opendnp3, a portable, rigorously-tested, Apache-licensed implementation of the DNP3 protocol (aka IEEE-1815).\n\n\nImportant Links\n\n\n\n\n\n\nProject Homepage\n - The official project homepage has older documentation links and other items.\n\n\n\n\n\n\nGithub Repository\n - You'll find the tagged releases here as well as the development branches.\n\n\n\n\n\n\nGoogle Group\n - Post questions and receive updates. Help there is provided on a \"as time permits\" basis.\n\n\n\n\n\n\nDNP Users Group\n - The official DNP user group. Your organization should join and get a copy of the standard.\n\n\n\n\n\n\nSupport options\n\n\nIf you need dedicated commercial support, custom integration services, or compliance/security testing contact \nAutomatak\n.\n\n\nIf the library does not contain a feature that you need for your device or application, please consider sponsoring the addition.\n\n\nAbout DNP3\n\n\nDNP3 (IEEE-1815, latest revision 2012) is am open, standardized SCADA protocol with a large feature set.  This guide (or the opendnp3 project in general)\ncannot teach you everything about DNP3. To successfully use opendnp3 or develop a product based on it, you will almost certainly need a copy of the specification.\nThe opendnp3 project recommends that your organization joins \nDNP.org\n to obtain a copy.\n\n\nForget everything you know about Modbus. \nDNP3 is event-oriented\n. The master doesn't have to constantly scan the outstation for every single point.\nInstead it requests changes in one of two modes:\n\n\n\n\n\n\nEvent polling\n - The master asks the outstations for changes on a regular interval (scan period). If nothing has changed, the response contains no measurement data.\nIf the response contains event data, the master confirms them so that the data is not repeated in subsequent responses. This mode works well in multi-drop scenarios\n(like a 900mhz radio tower talking to many outstations), but is definitely more chatty as the master is still required to do some level of polling.\n\n\n\n\n\n\nUnsolicited responses\n - The outstation \"pushes\" events to the master as they occur, and the master confirms them. This mode works well with IP-based networks where\nmultiple outstations can all talk to the master at the same time. You'll sometimes see this called \"quiescent mode\" since the network is silent when nothing is happening.\n\n\n\n\n\n\nUnderstanding how DNP3 is event-oriented is the single most important concept to grasp. There are many other subtleties and complexities to discover as you implement DNP3\nsoftware, but always keep this in mind.", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Welcome to opendnp3, a portable, rigorously-tested, Apache-licensed implementation of the DNP3 protocol (aka IEEE-1815).", 
            "title": "Introduction"
        }, 
        {
            "location": "/#important-links", 
            "text": "Project Homepage  - The official project homepage has older documentation links and other items.    Github Repository  - You'll find the tagged releases here as well as the development branches.    Google Group  - Post questions and receive updates. Help there is provided on a \"as time permits\" basis.    DNP Users Group  - The official DNP user group. Your organization should join and get a copy of the standard.", 
            "title": "Important Links"
        }, 
        {
            "location": "/#support-options", 
            "text": "If you need dedicated commercial support, custom integration services, or compliance/security testing contact  Automatak .  If the library does not contain a feature that you need for your device or application, please consider sponsoring the addition.", 
            "title": "Support options"
        }, 
        {
            "location": "/#about-dnp3", 
            "text": "DNP3 (IEEE-1815, latest revision 2012) is am open, standardized SCADA protocol with a large feature set.  This guide (or the opendnp3 project in general)\ncannot teach you everything about DNP3. To successfully use opendnp3 or develop a product based on it, you will almost certainly need a copy of the specification.\nThe opendnp3 project recommends that your organization joins  DNP.org  to obtain a copy.  Forget everything you know about Modbus.  DNP3 is event-oriented . The master doesn't have to constantly scan the outstation for every single point.\nInstead it requests changes in one of two modes:    Event polling  - The master asks the outstations for changes on a regular interval (scan period). If nothing has changed, the response contains no measurement data.\nIf the response contains event data, the master confirms them so that the data is not repeated in subsequent responses. This mode works well in multi-drop scenarios\n(like a 900mhz radio tower talking to many outstations), but is definitely more chatty as the master is still required to do some level of polling.    Unsolicited responses  - The outstation \"pushes\" events to the master as they occur, and the master confirms them. This mode works well with IP-based networks where\nmultiple outstations can all talk to the master at the same time. You'll sometimes see this called \"quiescent mode\" since the network is silent when nothing is happening.    Understanding how DNP3 is event-oriented is the single most important concept to grasp. There are many other subtleties and complexities to discover as you implement DNP3\nsoftware, but always keep this in mind.", 
            "title": "About DNP3"
        }, 
        {
            "location": "/features/features/", 
            "text": "Performance\n\n\nProbably the single biggest 'feature' of the library isn't a DNP3 specific feature at all. Opendnp3 significantly outperforms\nproprietary implementations of the protocol when it comes to large systems like masters with hundreds or even thousands of\nconcurrent sessions. There are a couple of reasons for this.\n\n\n\n\n\n\nOpendnp3 uses 100% non-blocking I/O and a thread-pool. There's no wasted context switching and thread-thrashing that plagues\nthread-per-session systems.  The system also automatically shares sessions across the thread pool so that no artificial sharing is\nrequired. Opendnp3 generally scales right up to your operating system limits.  We have the ASIO architecture to thank for\nmuch of this as it automatically picks the most efficient event loop (select, kqueue, epoll, etc) for your platform.\n\n\n\n\n\n\nZero-copy / zero-allocation parsing. When parsing an application layer message, the parser doesn't create a full object model\nrepresentation of the ASDU. Instead, it loops over the message in much the same way that a streaming XML parser does. This means\nthat messages can be parsed without heap allocation and very little stack usage as well.\n\n\n\n\n\n\nRobustness \n Security\n\n\nThe principal developers who work on opendnp3 have lead the charge in the industry in terms of \nsecurity testing DNP3\n.\nYou won't find a more reliable implementation of the protocol anywhere, even if you pay for it. Our commitment to a high-quality\nproject is evident in what we do.\n\n\n\n\nWe have an exhaustive unit test suite in excess of 80% coverage\n\n\nWe perform fuzzing using the \nAegis\n smart fuzzer as well as \nAFL\n.\n\n\nWe do \nautomated static analysis\n using Coverity and cppcheck\n\n\n\n\nWe provide integrated TLS support that makes opendnp3 an ideal solution for integrating with real-time markets programs like\n\nPJM Jetstream\n.\n\n\nCompliance\n\n\nIEEE-1815 defines 4 subset levels (1,2,3,4) that consist of the objects and function codes that must be supported by master and\noutstations to claim compliance. A device profile template that describes the supported objects and function codes can be found\non the documentation landing page.\n\n\nConformance tests only exist for subset levels 1 \n 2. Opendnp3 is routinely tested for subset level 2 using 3rd party tools, but\nyou can also configure the  library to act as a simple level 1 device. The stack currently meets all the level 2 subset requirements\nwith the notable except of support BROADCAST messages.  Very few people actually need this, and it's a questionable feature of the\nprotocol usually not recommended for use anymore.\n\n\nIn addition to Level 2 support, the following features are supported, but not tested since there are no official tests for them currently.\n\n\nLevels 1-3\n (FULL)\n\n\nLevel 4\n (PARTIAL)\n\n\n\n\nNo support for analog dead-band objects (group 34)\n\n\nOnly the master supports command event objects (groups 13 \n 43)\n\n\nNo support for device attributes (group 0)\n\n\n\n\nFunctionality not part of any level subset\n\n\n\n\nThe master supports reading octet strings (Group 110/111), the outstation has no support for sending them.\n\n\nNo support for virtual terminal objects\n\n\nNo support for file transfer\n\n\nNo support for data-sets\n\n\nNo support for secure authentication\n\n\n\n\nIf your integration requires some functionality not currently implemented, consider sponsoring the additions", 
            "title": "Features"
        }, 
        {
            "location": "/features/features/#performance", 
            "text": "Probably the single biggest 'feature' of the library isn't a DNP3 specific feature at all. Opendnp3 significantly outperforms\nproprietary implementations of the protocol when it comes to large systems like masters with hundreds or even thousands of\nconcurrent sessions. There are a couple of reasons for this.    Opendnp3 uses 100% non-blocking I/O and a thread-pool. There's no wasted context switching and thread-thrashing that plagues\nthread-per-session systems.  The system also automatically shares sessions across the thread pool so that no artificial sharing is\nrequired. Opendnp3 generally scales right up to your operating system limits.  We have the ASIO architecture to thank for\nmuch of this as it automatically picks the most efficient event loop (select, kqueue, epoll, etc) for your platform.    Zero-copy / zero-allocation parsing. When parsing an application layer message, the parser doesn't create a full object model\nrepresentation of the ASDU. Instead, it loops over the message in much the same way that a streaming XML parser does. This means\nthat messages can be parsed without heap allocation and very little stack usage as well.", 
            "title": "Performance"
        }, 
        {
            "location": "/features/features/#robustness-security", 
            "text": "The principal developers who work on opendnp3 have lead the charge in the industry in terms of  security testing DNP3 .\nYou won't find a more reliable implementation of the protocol anywhere, even if you pay for it. Our commitment to a high-quality\nproject is evident in what we do.   We have an exhaustive unit test suite in excess of 80% coverage  We perform fuzzing using the  Aegis  smart fuzzer as well as  AFL .  We do  automated static analysis  using Coverity and cppcheck   We provide integrated TLS support that makes opendnp3 an ideal solution for integrating with real-time markets programs like PJM Jetstream .", 
            "title": "Robustness &amp; Security"
        }, 
        {
            "location": "/features/features/#compliance", 
            "text": "IEEE-1815 defines 4 subset levels (1,2,3,4) that consist of the objects and function codes that must be supported by master and\noutstations to claim compliance. A device profile template that describes the supported objects and function codes can be found\non the documentation landing page.  Conformance tests only exist for subset levels 1   2. Opendnp3 is routinely tested for subset level 2 using 3rd party tools, but\nyou can also configure the  library to act as a simple level 1 device. The stack currently meets all the level 2 subset requirements\nwith the notable except of support BROADCAST messages.  Very few people actually need this, and it's a questionable feature of the\nprotocol usually not recommended for use anymore.  In addition to Level 2 support, the following features are supported, but not tested since there are no official tests for them currently.  Levels 1-3  (FULL)  Level 4  (PARTIAL)   No support for analog dead-band objects (group 34)  Only the master supports command event objects (groups 13   43)  No support for device attributes (group 0)   Functionality not part of any level subset   The master supports reading octet strings (Group 110/111), the outstation has no support for sending them.  No support for virtual terminal objects  No support for file transfer  No support for data-sets  No support for secure authentication   If your integration requires some functionality not currently implemented, consider sponsoring the additions", 
            "title": "Compliance"
        }, 
        {
            "location": "/build/requirements/", 
            "text": "Platforms\n\n\nOpendnp3 is a cross-platform C++ library. It targets all major operating systems including Linux, Windows, and OSX.\n\n\nC++14\n\n\nOpendnp3 uses the following C++11/14 features:\n\n\n\n\nstd::unique_ptr / std::shared_ptr\n - smart pointers are used for automatic memory management\n\n\nstd::thread\n - platform-independent threading using to manage the thread pool\n\n\nstd::chrono\n - platform-independent time operations including steady-clock used to manage timers\n\n\nvariadic templates\n - used in to simplify parsing routines.\n\n\n\n\nASIO\n\n\nASIO\n is a header-only library that provides asynchronous I/O (ASIO). Opendnp3 uses ASIO for several things.\n\n\n\n\nCross-platform sockets\n\n\nCross-platform serial ports\n\n\nA multi-core event loop\n\n\nAbstract timers on top of std::chrono\n\n\n\n\nCompilers\n\n\nThe following compilers are known to work, and are tested frequently.\n\n\n\n\nMSVC++ - Visual Studio 2015 and above\n\n\ng++ \n= 4.9.x\n\n\nclang \n= 3.5", 
            "title": "Requirements"
        }, 
        {
            "location": "/build/requirements/#platforms", 
            "text": "Opendnp3 is a cross-platform C++ library. It targets all major operating systems including Linux, Windows, and OSX.", 
            "title": "Platforms"
        }, 
        {
            "location": "/build/requirements/#c14", 
            "text": "Opendnp3 uses the following C++11/14 features:   std::unique_ptr / std::shared_ptr  - smart pointers are used for automatic memory management  std::thread  - platform-independent threading using to manage the thread pool  std::chrono  - platform-independent time operations including steady-clock used to manage timers  variadic templates  - used in to simplify parsing routines.", 
            "title": "C++14"
        }, 
        {
            "location": "/build/requirements/#asio", 
            "text": "ASIO  is a header-only library that provides asynchronous I/O (ASIO). Opendnp3 uses ASIO for several things.   Cross-platform sockets  Cross-platform serial ports  A multi-core event loop  Abstract timers on top of std::chrono", 
            "title": "ASIO"
        }, 
        {
            "location": "/build/requirements/#compilers", 
            "text": "The following compilers are known to work, and are tested frequently.   MSVC++ - Visual Studio 2015 and above  g++  = 4.9.x  clang  = 3.5", 
            "title": "Compilers"
        }, 
        {
            "location": "/build/libraries/", 
            "text": "Libraries\n\n\nAn overview of the directory structure is presented here. It describes only the most important elements, and is\nnot an exhaustive list of every folder in the project.\n\n\n# C++ projects built using CMake\n\n/cpp\n  /libs\n    /src\n      /openpal       // interfaces, containers, and parsers (Platform Abstraction Layer)\n      /opendnp3      // the core dnp3 library w/ no external dependencies other than openpal\n      /asiopal       // provides ASIO-based implementations of things in openpal\n      /asiodnp3      // high-level dnp3 interface that leverage asiopal\n      /dnp3decode    // a dnp3 decoder based on the opendnp3 parsers\n\n  /examples         // various example programs of using opendnp3\n  /tests            // unit tests and shared helper libraries  \n\n\n\n\nThe dependencies between the libraries for linking purposes can be defined as:\n\n\nopendnp3 -\n { openpal }\n\n\nasiopal -\n  { openpal }\n\n\nasiodnp3 -\n { opendnp3, asiopal, openpal }\n\n\nWhen building an external application on Linux for instance, you need to link against all four libraries:\n\n\n-lasiodnp3 -lasiopal -lopendnp3 -lopenpal\n\n\n\n\nCLR Bindings\n\n\n# CLR bindings built using external SLN\n\n/dotnet\n  /bindings\n    /CLRInterface   // Pure CLR interfaces and classes that comprise the API\n    /CLRAdapter     // a C++/CLI project that adapters the underlying C++ libraries to C#\n\n\n\n\nJava Bindings\n\n\n# Java bindings built using CMake (native) and Maven (pom.xml)\n\n/java\n  /api            // pure Java classes\n  /bindings       // Java w/ native stubs\n  /codegen        // Code generator written in Scala that generates C++ JNI boilerplate\n  /cpp            // C++ compiled to libopendnp3java.dll/so\n  /example        // Java example programs that depend on api/bindings Jars", 
            "title": "Libraries"
        }, 
        {
            "location": "/build/libraries/#libraries", 
            "text": "An overview of the directory structure is presented here. It describes only the most important elements, and is\nnot an exhaustive list of every folder in the project.  # C++ projects built using CMake\n\n/cpp\n  /libs\n    /src\n      /openpal       // interfaces, containers, and parsers (Platform Abstraction Layer)\n      /opendnp3      // the core dnp3 library w/ no external dependencies other than openpal\n      /asiopal       // provides ASIO-based implementations of things in openpal\n      /asiodnp3      // high-level dnp3 interface that leverage asiopal\n      /dnp3decode    // a dnp3 decoder based on the opendnp3 parsers\n\n  /examples         // various example programs of using opendnp3\n  /tests            // unit tests and shared helper libraries    The dependencies between the libraries for linking purposes can be defined as:  opendnp3 -  { openpal }  asiopal -   { openpal }  asiodnp3 -  { opendnp3, asiopal, openpal }  When building an external application on Linux for instance, you need to link against all four libraries:  -lasiodnp3 -lasiopal -lopendnp3 -lopenpal", 
            "title": "Libraries"
        }, 
        {
            "location": "/build/libraries/#clr-bindings", 
            "text": "# CLR bindings built using external SLN\n\n/dotnet\n  /bindings\n    /CLRInterface   // Pure CLR interfaces and classes that comprise the API\n    /CLRAdapter     // a C++/CLI project that adapters the underlying C++ libraries to C#", 
            "title": "CLR Bindings"
        }, 
        {
            "location": "/build/libraries/#java-bindings", 
            "text": "# Java bindings built using CMake (native) and Maven (pom.xml)\n\n/java\n  /api            // pure Java classes\n  /bindings       // Java w/ native stubs\n  /codegen        // Code generator written in Scala that generates C++ JNI boilerplate\n  /cpp            // C++ compiled to libopendnp3java.dll/so\n  /example        // Java example programs that depend on api/bindings Jars", 
            "title": "Java Bindings"
        }, 
        {
            "location": "/build/cmake/", 
            "text": "CMake\n\n\nOpendnp3 uses a build system generator called \nCMake\n.  This means that the actual build files (e.g. a Makefile or Microsfot .SLN) are generated from a\ncommon artifact called \nCMakeLists.txt\n. You can see what one looks like \nhere\n.\n\n\nThis allows the opendnp3 project to maintain a build file for all platforms, and greatly reduces per-platform maintenance. CMake also integrates nicely with\nLinux C++ IDEs like \nKDevelop\n or \nCLion\n.\n\n\nOne of the more attractive parts of CMake is that it supports \nout-of-source builds\n.\n\n\nLocating ASIO\n\n\nThe include sub-folder of the ASIO distribution (the folder that contains 'asio.hpp') needs to be on your include path, but there are several ways you can do this.\nYou can choose the option that makes the most sense your particular build environment. CMake will try the following things in order to locate your ASIO.\n\n\n1) Look to see if you checked out ASIO as a git submodule when cloning opendnp3 \n\n\n git clone --recursive https://github.com/automatak/dnp3.git\n\n\n\n\n2) If 1) fails, it will look to see if the variable ASIO_HOME was defined via the cmake command line.\n\n\n cmake ../dnp3 -DASIO_HOME=C:\\libs\\asio-asio-1-10-8\\asio\\include\n\n\n\n\n3) If 1) and 2) fail, it will check to see if it is defined as an environment variable.\n\n\nFor instance, on Windows you might define your environment variable to look like this.\n\n\nASIO_HOME=C:\\libs\\asio-asio-1-10-8\\asio\\include\n\n\n\n\nOn Ubuntu Linux, you might add a line to ~/.bashrc as follows:\n\n\nexport ASIO_HOME=~/asio-asio-1-10-8/asio/include\n\n\n\n\nLastly, cmake will just assume the headers are installed on the system. No checks are performed, so the build will fail is this isn't true\n\n\nOptional Components\n\n\nBy default, cmake will not build tests, demos, or TLS support. You can enable each optional component individually by specifying\nthem on the command line:\n\n\n cmake ../dnp3 -D\noption\n=ON\n\n\n\n\n\n\n\n\n\n\nOption Name\n\n\nComments\n\n\n\n\n\n\n\n\n\n\nDNP3_ALL\n\n\nbuild all optional components below\n\n\n\n\n\n\nDNP3_DEMO\n\n\nexample programs\n\n\n\n\n\n\nDNP3_JAVA\n\n\njava bindings shared library\n\n\n\n\n\n\nDNP3_TEST\n\n\nunit test suites\n\n\n\n\n\n\nDNP3_TLS\n\n\nsupport for TLS channels (requires openssl)\n\n\n\n\n\n\nDNP3_DECODER\n\n\ndecoder module\n\n\n\n\n\n\n\n\nFor example, to build the demos including TLS support:\n\n\n cmake ../dnp3 -DDNP3_DEMO=ON -DDNP3_TLS=ON\n\n\n\n\nBuild Options\n\n\nMost of command-line options you can feed to CMake to generate your build environment are platform-independent.  This documentation can't tell you everything that\nCMake can do. We only document some of the more common flags here for your convenience. All of the following examples assume an out-of-source build folder in a\nsibling directory to the opendnp3 distribution.\n\n\nStatic vs Dynamic Linking\n\n\nYou can switch between building static or dynamic linking using the STATICLIBS flag. Note that this flag is provided by the project and is not a CMake flag.\n\n\nOn Windows, static libs are the default. On Linux, dynamic libs are the default.\n\n\n cmake ../dnp3 STATICLIBS=ON   # build static libraries\n\n cmake ../dnp3 STATICLIBS=OFF  # build dynamic libraries\n\n\n\n\nDebug vs Release\n\n\nYou can configure release vs debug builds using the CMAKE_BUILD_TYPE flag\nNote that on windows, the generated SLN contains debug and release build targets already\n\n\n cmake ../dnp3 -DCMAKE_BUILD_TYPE=Debug\n\n cmake ../dnp3 -DCMAKE_BUILD_TYPE=Release\n\n\n\n\nNon-default generators\n\n\nBy default, CMake will pick a generator to use if you don't tell it which one. You can see a list of all available generators using the help flag.\n\n\n cmake --help\n\n\n\n\nYou can then specify a specific generator, e.g. to do a full 64-bit build on Windows:\n\n\n mkdir build64\n\n cmake .. -DDNP3_ALL=ON -G \nVisual Studio 14 2015 Win64\n\n\n\n\n\nSetting the install prefix\n\n\nThe default install prefix probably won't be right for your platform. You can configure it using CMAKE_INSTALL_PREFIX.\n\n\nOn Debian-based systems this should probably be:\n\n\n cmake .. -DCMAKE_INSTALL_PREFIX=/usr\n\n\n\n\nOn windows, you might put your libraries and headers somewhere like:\n\n\n cmake .. -DCMAKE_INSTALL_PREFIX=C:\\libs\\opendnp3\n\n\n\n\nBuilding on Linux\n\n\nOn Linux, the easiest way to use CMake is just to let it create a makefile for you. You can then use this makefile in the same way you normally would.\n\n\n cmake .. \noptions\n\n\n make\n\n sudo make install", 
            "title": "CMake"
        }, 
        {
            "location": "/build/cmake/#cmake", 
            "text": "Opendnp3 uses a build system generator called  CMake .  This means that the actual build files (e.g. a Makefile or Microsfot .SLN) are generated from a\ncommon artifact called  CMakeLists.txt . You can see what one looks like  here .  This allows the opendnp3 project to maintain a build file for all platforms, and greatly reduces per-platform maintenance. CMake also integrates nicely with\nLinux C++ IDEs like  KDevelop  or  CLion .  One of the more attractive parts of CMake is that it supports  out-of-source builds .", 
            "title": "CMake"
        }, 
        {
            "location": "/build/cmake/#locating-asio", 
            "text": "The include sub-folder of the ASIO distribution (the folder that contains 'asio.hpp') needs to be on your include path, but there are several ways you can do this.\nYou can choose the option that makes the most sense your particular build environment. CMake will try the following things in order to locate your ASIO.  1) Look to see if you checked out ASIO as a git submodule when cloning opendnp3    git clone --recursive https://github.com/automatak/dnp3.git  2) If 1) fails, it will look to see if the variable ASIO_HOME was defined via the cmake command line.   cmake ../dnp3 -DASIO_HOME=C:\\libs\\asio-asio-1-10-8\\asio\\include  3) If 1) and 2) fail, it will check to see if it is defined as an environment variable.  For instance, on Windows you might define your environment variable to look like this.  ASIO_HOME=C:\\libs\\asio-asio-1-10-8\\asio\\include  On Ubuntu Linux, you might add a line to ~/.bashrc as follows:  export ASIO_HOME=~/asio-asio-1-10-8/asio/include  Lastly, cmake will just assume the headers are installed on the system. No checks are performed, so the build will fail is this isn't true", 
            "title": "Locating ASIO"
        }, 
        {
            "location": "/build/cmake/#optional-components", 
            "text": "By default, cmake will not build tests, demos, or TLS support. You can enable each optional component individually by specifying\nthem on the command line:   cmake ../dnp3 -D option =ON     Option Name  Comments      DNP3_ALL  build all optional components below    DNP3_DEMO  example programs    DNP3_JAVA  java bindings shared library    DNP3_TEST  unit test suites    DNP3_TLS  support for TLS channels (requires openssl)    DNP3_DECODER  decoder module     For example, to build the demos including TLS support:   cmake ../dnp3 -DDNP3_DEMO=ON -DDNP3_TLS=ON", 
            "title": "Optional Components"
        }, 
        {
            "location": "/build/cmake/#build-options", 
            "text": "Most of command-line options you can feed to CMake to generate your build environment are platform-independent.  This documentation can't tell you everything that\nCMake can do. We only document some of the more common flags here for your convenience. All of the following examples assume an out-of-source build folder in a\nsibling directory to the opendnp3 distribution.  Static vs Dynamic Linking  You can switch between building static or dynamic linking using the STATICLIBS flag. Note that this flag is provided by the project and is not a CMake flag.  On Windows, static libs are the default. On Linux, dynamic libs are the default.   cmake ../dnp3 STATICLIBS=ON   # build static libraries  cmake ../dnp3 STATICLIBS=OFF  # build dynamic libraries  Debug vs Release  You can configure release vs debug builds using the CMAKE_BUILD_TYPE flag\nNote that on windows, the generated SLN contains debug and release build targets already   cmake ../dnp3 -DCMAKE_BUILD_TYPE=Debug  cmake ../dnp3 -DCMAKE_BUILD_TYPE=Release  Non-default generators  By default, CMake will pick a generator to use if you don't tell it which one. You can see a list of all available generators using the help flag.   cmake --help  You can then specify a specific generator, e.g. to do a full 64-bit build on Windows:   mkdir build64  cmake .. -DDNP3_ALL=ON -G  Visual Studio 14 2015 Win64   Setting the install prefix  The default install prefix probably won't be right for your platform. You can configure it using CMAKE_INSTALL_PREFIX.  On Debian-based systems this should probably be:   cmake .. -DCMAKE_INSTALL_PREFIX=/usr  On windows, you might put your libraries and headers somewhere like:   cmake .. -DCMAKE_INSTALL_PREFIX=C:\\libs\\opendnp3", 
            "title": "Build Options"
        }, 
        {
            "location": "/build/cmake/#building-on-linux", 
            "text": "On Linux, the easiest way to use CMake is just to let it create a makefile for you. You can then use this makefile in the same way you normally would.   cmake ..  options   make  sudo make install", 
            "title": "Building on Linux"
        }, 
        {
            "location": "/build/linux/", 
            "text": "Make / install\n\n\nOn linux, the easiest way to use CMake is just to let it create a makefile for you. You can then use this makefile in the same\nway you normally would.\n\n\n cmake ../dnp3 \noptions\n\n\n make -j\n\n sudo make install\n\n\n\n\nCross-compiling\n\n\nCMake also supports cross-compiling to embedded-linux platforms. How to do this is outside the scope of this documentation, but is \nexplained \nhere\n.\n\n\nThe preferred method is to create a toolchain file for each target platform.", 
            "title": "Linux"
        }, 
        {
            "location": "/build/linux/#make-install", 
            "text": "On linux, the easiest way to use CMake is just to let it create a makefile for you. You can then use this makefile in the same\nway you normally would.   cmake ../dnp3  options   make -j  sudo make install", 
            "title": "Make / install"
        }, 
        {
            "location": "/build/linux/#cross-compiling", 
            "text": "CMake also supports cross-compiling to embedded-linux platforms. How to do this is outside the scope of this documentation, but is \nexplained  here .  The preferred method is to create a toolchain file for each target platform.", 
            "title": "Cross-compiling"
        }, 
        {
            "location": "/build/windows/", 
            "text": "Visual Studio SLN\n\n\nOn windows, CMake is used to generate a SLN and associated project files.\n\n\n mkdir build\n\n cd build\n\n cmake .. \noptions\n\n\n\n\n\nOnce you've generated your SLN, you can just open it and use Visual Studio to build the project for you just like any other project.\n\n\nCommand Line\n\n\nAlternatively, you can just invoke msbuild.exe on the generated solution and build from the command line.\n\n\n msbuild opendnp3.sln\n\n\n\n\nInstalling\n\n\nCMake creates a special project called \"install\" that you can run inside Visual Studio to install the headers and libraries to\nthe directory specified by CMAKE_INSTALL_PREFIX.\n\n\nTLS Support\n\n\nIf you need to build the stack w/ TLS support (or you're using the .NET bindings), then you need to install openssl on Windows.  Use the installers\nfrom \nShiningLight\n.\n\n\n.NET Bindings\n\n\nBy far, the easiest way to use the .NET bindings is just to install the Nuget package we publish:\n\n\nPM\n Install-Package opendnp3\n\n\n\n\nor to allow pre-release versions:\n\n\nPM\n Install-Package opendnp3 -Pre\n\n\n\n\nManually building\n\n\nBuilding the .NET bindings requires linking to openssl. As a result, you need to create and install an opendnp3 build\nwith -DFULL=ON set when creating the SLN.\n\n\nThe .NET bindings use a separate SLN located in the 'dotnet' folder (bindings.sln). They treat the C++ libraries as if they were a dependency. There are a few environment variables you need to define so that the SLN can find opendnp3.\n\n\n\n\nOPENDNP3_DIR - The directory where opendnp3 was installed, e.g. your argument to CMAKE_INSTALL_PREFIX\n\n\nOSSL_LIB32_DIR - The directory where the 32-bit openssl libraries are installed, e.g. C:\\OpenSSL-Win32\\lib\\VC\\static\n\n\nOSSL_LIB64_DIR - The directory where the 64-bit openssl libraries are installed, e.g. C:\\OpenSSL-Win64\\lib\\VC\\static\n\n\n\n\nUsing the \"static\" directory of the openssl distribution will create .NET bindings that statically link all of openssl. If you'd prefer to link dynamically use\nthe \"lib/VC\" directory instead.\n\n\nYou don't need to define both the 32/64 bit library locations. Just define what you plan on building.", 
            "title": "Windows"
        }, 
        {
            "location": "/build/windows/#visual-studio-sln", 
            "text": "On windows, CMake is used to generate a SLN and associated project files.   mkdir build  cd build  cmake ..  options   Once you've generated your SLN, you can just open it and use Visual Studio to build the project for you just like any other project.", 
            "title": "Visual Studio SLN"
        }, 
        {
            "location": "/build/windows/#command-line", 
            "text": "Alternatively, you can just invoke msbuild.exe on the generated solution and build from the command line.   msbuild opendnp3.sln", 
            "title": "Command Line"
        }, 
        {
            "location": "/build/windows/#installing", 
            "text": "CMake creates a special project called \"install\" that you can run inside Visual Studio to install the headers and libraries to\nthe directory specified by CMAKE_INSTALL_PREFIX.", 
            "title": "Installing"
        }, 
        {
            "location": "/build/windows/#tls-support", 
            "text": "If you need to build the stack w/ TLS support (or you're using the .NET bindings), then you need to install openssl on Windows.  Use the installers\nfrom  ShiningLight .", 
            "title": "TLS Support"
        }, 
        {
            "location": "/build/windows/#net-bindings", 
            "text": "By far, the easiest way to use the .NET bindings is just to install the Nuget package we publish:  PM  Install-Package opendnp3  or to allow pre-release versions:  PM  Install-Package opendnp3 -Pre  Manually building  Building the .NET bindings requires linking to openssl. As a result, you need to create and install an opendnp3 build\nwith -DFULL=ON set when creating the SLN.  The .NET bindings use a separate SLN located in the 'dotnet' folder (bindings.sln). They treat the C++ libraries as if they were a dependency. There are a few environment variables you need to define so that the SLN can find opendnp3.   OPENDNP3_DIR - The directory where opendnp3 was installed, e.g. your argument to CMAKE_INSTALL_PREFIX  OSSL_LIB32_DIR - The directory where the 32-bit openssl libraries are installed, e.g. C:\\OpenSSL-Win32\\lib\\VC\\static  OSSL_LIB64_DIR - The directory where the 64-bit openssl libraries are installed, e.g. C:\\OpenSSL-Win64\\lib\\VC\\static   Using the \"static\" directory of the openssl distribution will create .NET bindings that statically link all of openssl. If you'd prefer to link dynamically use\nthe \"lib/VC\" directory instead.  You don't need to define both the 32/64 bit library locations. Just define what you plan on building.", 
            "title": ".NET Bindings"
        }, 
        {
            "location": "/build/java/", 
            "text": "Components\n\n\nThe opendnp3 Java bindings are built as two separate pieces: a normal Java JAR file and a native shared library\nbuilt from the companion C++ source. Java 1.8 or greater is required.\n\n\nC++ bindings\n\n\nUse the '-DDNP3_JAVA=ON' option when invoking CMake. CMake will locate your JNI headers using the JAVA_HOME environment variable. The shared\nlibrary must be installed in a system location or the path specified using the 'system.library.path' VM option.\n\n\nJava library\n\n\nThe java library is built and installed locally using Maven.\n\n\n cd java\n\n mvn install\n\n\n\n\nYou can now use it in your Maven based Java projects using \n\n\ndependencies\n\n...\n    \ndependency\n\n        \ngroupId\ncom.automatak.dnp3\n/groupId\n\n        \nartifactId\nopendnp3-bindings\n/artifactId\n\n        \nversion\n${opendnp3.version}\n/version\n\n    \n/dependency\n\n...\n\n/dependencies", 
            "title": "Java"
        }, 
        {
            "location": "/build/java/#components", 
            "text": "The opendnp3 Java bindings are built as two separate pieces: a normal Java JAR file and a native shared library\nbuilt from the companion C++ source. Java 1.8 or greater is required.", 
            "title": "Components"
        }, 
        {
            "location": "/build/java/#c-bindings", 
            "text": "Use the '-DDNP3_JAVA=ON' option when invoking CMake. CMake will locate your JNI headers using the JAVA_HOME environment variable. The shared\nlibrary must be installed in a system location or the path specified using the 'system.library.path' VM option.", 
            "title": "C++ bindings"
        }, 
        {
            "location": "/build/java/#java-library", 
            "text": "The java library is built and installed locally using Maven.   cd java  mvn install  You can now use it in your Maven based Java projects using   dependencies \n...\n     dependency \n         groupId com.automatak.dnp3 /groupId \n         artifactId opendnp3-bindings /artifactId \n         version ${opendnp3.version} /version \n     /dependency \n... /dependencies", 
            "title": "Java library"
        }, 
        {
            "location": "/api/architecture/", 
            "text": "DNP3Manager\n\n\nAll opendnp3 programs begin by creating a \nDNP3Manager\n.  Creating this object allocates a thread pool used\nto process events and callbacks to user code.\n\n\n// Create a root DNP3 manager with a single thread that logs to the console\nDNP3Manager manager(1, ConsoleLogger::Create());\n\n\n\n\nIf you're familiar with using ASIO in other contexts, than it should be no surprise that the DNP3Manager owns an \nasio::io_context\n.\nIt also has a thread pool for calling \nasio::io_context::run()\n, but this is an internal detail that most opendnp3 programmers do\nnot need to know to use the stack.\n\n\nHow many threads you allocate to your thread pool can be a subtle matter. On simple systems like a small outstation that only\ntalks to a single master, one thread is sufficient. For masters that may talk to hundreds or thousands of outstations, you'll\nwant to scale your thread-pool to the number of logical processors on your machine.\n\n\n// Create a root DNP3 manager as many threads as logical processors\nDNP3Manager manager(std::hardware_concurrency(), ConsoleLogger::Create());\n\n\n\n\nYou should avoid blocking the stack during callbacks\n made to user code.  This advice is especially critical for large systems where\nthe number of communication channels greatly outnumbers the number of threads in the pool. If all of your threads are blocked\nthen other channels can't do useful work like sending control requests to the field. If you must design your system to do some blocking,\nyou can mitigate this problem by scaling the number of threads in the pool as a multiple of the number of cores.\n\n\n// Create a root DNP3 manager with twice as many threads as logical processors\nDNP3Manager manager(2*std::hardware_concurrency(), ConsoleLogger::Create());\n\n\n\n\nProperly configuring your thread pool ensures optimal performance.\n\n\nChannels \n Sessions\n\n\nCommunication channels are created from the root DNP3Manager class.\n\n\n// Create a TCP client channel to which we can bind masters or outstations\nauto channel = manager.AddTCPClient(...arguments...);\n\n\n\n\nThere is a unique method for adding each supported channel type, TCPClient, TCPServer, TLSClient, TLSServer, or Serial. You should refer to code documentation\nfor a description of the parameters.\n\n\nWith your channels created you can now bind master or outstations sessions to your them.  Binding multiple master or outstations sessions to a single channel\nis a \nmulti-drop\n configuration.\n\n\n// Create a master bound to a particular channel\nauto master = channel-\nAddMaster(...arguments...);\n\n// Create an outstation bound to particular channel\nauto  outstation = channel-\nAddOutstation(...arguments...);\n\n\n\n\nArchitecture\n\n\nEach channel and the sessions bound to it, are a single-threaded state-machine.  During execution, ASIO guarantees that each channel\nis only processing one event at a time from a single thread. This means that there is no explicit thread synchronization required any where in the stack.\nWhen user code wants to communicate with a stack, e.g. load measurement data into an outstation or request that a command be initiated\non a master, it gets \"posted\" to the correct channel's executor. This ensures that each channel and all the sessions bound to it are\nonly ever touched by a single thread at a time.\n\n\nUser code, however, may need to worry about multi-threading. If you hand the same callback interface to multiple sessions, you will\npotentially receive callbacks from multiple threads simultaneously on the same interface.", 
            "title": "Architecture"
        }, 
        {
            "location": "/api/architecture/#dnp3manager", 
            "text": "All opendnp3 programs begin by creating a  DNP3Manager .  Creating this object allocates a thread pool used\nto process events and callbacks to user code.  // Create a root DNP3 manager with a single thread that logs to the console\nDNP3Manager manager(1, ConsoleLogger::Create());  If you're familiar with using ASIO in other contexts, than it should be no surprise that the DNP3Manager owns an  asio::io_context .\nIt also has a thread pool for calling  asio::io_context::run() , but this is an internal detail that most opendnp3 programmers do\nnot need to know to use the stack.  How many threads you allocate to your thread pool can be a subtle matter. On simple systems like a small outstation that only\ntalks to a single master, one thread is sufficient. For masters that may talk to hundreds or thousands of outstations, you'll\nwant to scale your thread-pool to the number of logical processors on your machine.  // Create a root DNP3 manager as many threads as logical processors\nDNP3Manager manager(std::hardware_concurrency(), ConsoleLogger::Create());  You should avoid blocking the stack during callbacks  made to user code.  This advice is especially critical for large systems where\nthe number of communication channels greatly outnumbers the number of threads in the pool. If all of your threads are blocked\nthen other channels can't do useful work like sending control requests to the field. If you must design your system to do some blocking,\nyou can mitigate this problem by scaling the number of threads in the pool as a multiple of the number of cores.  // Create a root DNP3 manager with twice as many threads as logical processors\nDNP3Manager manager(2*std::hardware_concurrency(), ConsoleLogger::Create());  Properly configuring your thread pool ensures optimal performance.", 
            "title": "DNP3Manager"
        }, 
        {
            "location": "/api/architecture/#channels-sessions", 
            "text": "Communication channels are created from the root DNP3Manager class.  // Create a TCP client channel to which we can bind masters or outstations\nauto channel = manager.AddTCPClient(...arguments...);  There is a unique method for adding each supported channel type, TCPClient, TCPServer, TLSClient, TLSServer, or Serial. You should refer to code documentation\nfor a description of the parameters.  With your channels created you can now bind master or outstations sessions to your them.  Binding multiple master or outstations sessions to a single channel\nis a  multi-drop  configuration.  // Create a master bound to a particular channel\nauto master = channel- AddMaster(...arguments...);\n\n// Create an outstation bound to particular channel\nauto  outstation = channel- AddOutstation(...arguments...);", 
            "title": "Channels &amp; Sessions"
        }, 
        {
            "location": "/api/architecture/#architecture", 
            "text": "Each channel and the sessions bound to it, are a single-threaded state-machine.  During execution, ASIO guarantees that each channel\nis only processing one event at a time from a single thread. This means that there is no explicit thread synchronization required any where in the stack.\nWhen user code wants to communicate with a stack, e.g. load measurement data into an outstation or request that a command be initiated\non a master, it gets \"posted\" to the correct channel's executor. This ensures that each channel and all the sessions bound to it are\nonly ever touched by a single thread at a time.  User code, however, may need to worry about multi-threading. If you hand the same callback interface to multiple sessions, you will\npotentially receive callbacks from multiple threads simultaneously on the same interface.", 
            "title": "Architecture"
        }, 
        {
            "location": "/api/logging/", 
            "text": "Listening\n\n\nYou can bind to the opendnp3 log stream by calling passing a \nshared_ptr\n into the  \nDNP3Manager\n constructor. This interface\njust has a single method:\n\n\nclass ILogHandler\n{\npublic:\n    virtual void Log( const LogEntry\n entry ) = 0;\n};\n\n\n\n\nIf you need to send log messages to more than one location, create your own proxy \nIlogHandler\n. Keep in mind that this is a callback from the\nthread-pool and will block that thread from executing. A good strategy for a file-logger in a big system would be to send a message\nto a worker thread to write the message to disk.\n\n\nIndividual loggers\n\n\nEach channel and stack instance (master or outstation) has its own logger whose log level can be individually configured and adjusted at run-time. This allows you increase the log-level of a particular channel or stack, without\nreceiving full protocol analysis for everything and grinding the system to a halt. You specify the initial log level for each channel when it is created and this is inherited by stacks on that channel. You can adjust it\nduring execute by calling \nIChannel::SetLogFilters\n, \nIMaster::SetLogFilters\n, or \nIOutstation::SetLogFilters\n.\n\n\nLog levels\n\n\nOpendnp3 defines a number of typical log levels like DEBUG, INFO, WARN, ERR. In addition it defines a number of log levels specific to the protocol dissection and analysis. Turning\non all the various DNP3 analysis levels allows you to create useful communication traces like the following.\n\n\nms(1440709781929) \n-TL--  outstation - FIR: 1 FIN: 1 SEQ: 0 LEN: 11\nms(1440709781932) \n-AL--  outstation - C0 15 3C 02 06 3C 03 06 3C 04 06\nms(1440709781934) \n-AL--  outstation - FIR: 1 FIN: 1 CON: 0 UNS: 0 SEQ: 0 FUNC: DISABLE_UNSOLICITED\nms(1440709781939) \n-AL--  outstation - 060,002 - Class Data - Class 1 - all objects\nms(1440709781944) \n-AL--  outstation - 060,003 - Class Data - Class 2 - all objects\nms(1440709781949) \n-AL--  outstation - 060,004 - Class Data - Class 3 - all objects", 
            "title": "Logging"
        }, 
        {
            "location": "/api/logging/#listening", 
            "text": "You can bind to the opendnp3 log stream by calling passing a  shared_ptr  into the   DNP3Manager  constructor. This interface\njust has a single method:  class ILogHandler\n{\npublic:\n    virtual void Log( const LogEntry  entry ) = 0;\n};  If you need to send log messages to more than one location, create your own proxy  IlogHandler . Keep in mind that this is a callback from the\nthread-pool and will block that thread from executing. A good strategy for a file-logger in a big system would be to send a message\nto a worker thread to write the message to disk.", 
            "title": "Listening"
        }, 
        {
            "location": "/api/logging/#individual-loggers", 
            "text": "Each channel and stack instance (master or outstation) has its own logger whose log level can be individually configured and adjusted at run-time. This allows you increase the log-level of a particular channel or stack, without\nreceiving full protocol analysis for everything and grinding the system to a halt. You specify the initial log level for each channel when it is created and this is inherited by stacks on that channel. You can adjust it\nduring execute by calling  IChannel::SetLogFilters ,  IMaster::SetLogFilters , or  IOutstation::SetLogFilters .", 
            "title": "Individual loggers"
        }, 
        {
            "location": "/api/logging/#log-levels", 
            "text": "Opendnp3 defines a number of typical log levels like DEBUG, INFO, WARN, ERR. In addition it defines a number of log levels specific to the protocol dissection and analysis. Turning\non all the various DNP3 analysis levels allows you to create useful communication traces like the following.  ms(1440709781929)  -TL--  outstation - FIR: 1 FIN: 1 SEQ: 0 LEN: 11\nms(1440709781932)  -AL--  outstation - C0 15 3C 02 06 3C 03 06 3C 04 06\nms(1440709781934)  -AL--  outstation - FIR: 1 FIN: 1 CON: 0 UNS: 0 SEQ: 0 FUNC: DISABLE_UNSOLICITED\nms(1440709781939)  -AL--  outstation - 060,002 - Class Data - Class 1 - all objects\nms(1440709781944)  -AL--  outstation - 060,003 - Class Data - Class 2 - all objects\nms(1440709781949)  -AL--  outstation - 060,004 - Class Data - Class 3 - all objects", 
            "title": "Log levels"
        }, 
        {
            "location": "/api/channels/", 
            "text": "Creating a channel\n\n\nThe opendnp3 library uses an abstract communication channels to send and receive bytes \"over the wire\". Opendnp3 supports TCP client/server\nand serial communications currently, but UDP and TLS encrypted TCP may be added in the future.\n\n\nThe manager that you created previously is now ready to have some channels bound to it. Adding a channel to the manager\ndoes not make it attempt to open immediately. If it's a TCP socket or serial port it won't try to open until you bind at least one outstation\nor master session and enable it. Here's an example of how you go about adding a TCP client. Assume we have a DNP3Manager called 'manager':\n\n\nauto channel = manager.AddTCPClient(\n  \ntcpclient\n,                            // alias used in log messages\n  levels::NORMAL,                         // bitfield used to filter what gets logged\n  ChannelRetry::Default(),                // determines how connections will be retried\n  \n127.0.0.1\n,                            // host name (DNS resolved) or IP address of remote endpoint\n  \n0.0.0.0\n,                              // adapter on which to attempt the connection (any adapter)\n  20000,                                  // port remote endpoint is listening on\n  nullptr                                 // optional listener interface for monitoring the channel\n);\n\n\n\n\nThe API for creating TCPServer channels or Serial channels is very similar. Just refer to the code documentation.\n\n\nChannelRetry\n and exponential backoff\n\n\nThe \nChannelRetry\n configuration specifies two timing parameters for the minimum and maximum connection retry times using an exponential back-off strategy. If you don't want\nexponential back-off, just set the minimum and maximum to the same value for a consistent delay. Exponential back-off really only makes sense for initiating TCP connections.\n\n\nFor instance if you set the minimum to \nTimeDuration::Seconds(3)\n and the maximum to \nTimeDuration::Seconds(40)\n a series of failed connections would have the following\ntime gaps between attempts.\n\n\n3, 6, 12, 24, 40, 40, .....\n\n\nMonitoring channels\n\n\nMost of the time your communication channel is open and passing dnp3 traffic back and forth. Sometimes, however, things can go wrong with your network or you have mis-configured your connection. when\ncreating your channel, you can pass in a shared_ptr\n to monitor the state of channel. This interface provides a method returning an enumeration of the states of the channel:\n\n\nenum class ChannelState : uint8_t\n{\n    /// offline and idle\n    CLOSED = 0,\n    /// trying to open\n    OPENING = 1,\n    /// open\n    OPEN = 2,\n    /// stopped and will never do anything again\n    SHUTDOWN = 3\n};\n\n\n\n\nCleaning up channels\n\n\nChannels and all the sessions bound to them are automatically cleaned up when the DNP3Manager goes out of scope\n(or is deleted if allocated dynamically). You can manually remove a channel without having to stop every master or outstation bound\nto it by calling \nIChannel::Shutdown()\n.\n\n\n// permanently shutdown the channel\nchannel-\nShutdown();\n\n\n\n\nCalls to Shutdown() are idempotent. The resources for the underlying channel will be freed\nwhen you drop the reference to the shared_ptr.", 
            "title": "Channels"
        }, 
        {
            "location": "/api/channels/#creating-a-channel", 
            "text": "The opendnp3 library uses an abstract communication channels to send and receive bytes \"over the wire\". Opendnp3 supports TCP client/server\nand serial communications currently, but UDP and TLS encrypted TCP may be added in the future.  The manager that you created previously is now ready to have some channels bound to it. Adding a channel to the manager\ndoes not make it attempt to open immediately. If it's a TCP socket or serial port it won't try to open until you bind at least one outstation\nor master session and enable it. Here's an example of how you go about adding a TCP client. Assume we have a DNP3Manager called 'manager':  auto channel = manager.AddTCPClient(\n   tcpclient ,                            // alias used in log messages\n  levels::NORMAL,                         // bitfield used to filter what gets logged\n  ChannelRetry::Default(),                // determines how connections will be retried\n   127.0.0.1 ,                            // host name (DNS resolved) or IP address of remote endpoint\n   0.0.0.0 ,                              // adapter on which to attempt the connection (any adapter)\n  20000,                                  // port remote endpoint is listening on\n  nullptr                                 // optional listener interface for monitoring the channel\n);  The API for creating TCPServer channels or Serial channels is very similar. Just refer to the code documentation.", 
            "title": "Creating a channel"
        }, 
        {
            "location": "/api/channels/#channelretry-and-exponential-backoff", 
            "text": "The  ChannelRetry  configuration specifies two timing parameters for the minimum and maximum connection retry times using an exponential back-off strategy. If you don't want\nexponential back-off, just set the minimum and maximum to the same value for a consistent delay. Exponential back-off really only makes sense for initiating TCP connections.  For instance if you set the minimum to  TimeDuration::Seconds(3)  and the maximum to  TimeDuration::Seconds(40)  a series of failed connections would have the following\ntime gaps between attempts.  3, 6, 12, 24, 40, 40, .....", 
            "title": "ChannelRetry and exponential backoff"
        }, 
        {
            "location": "/api/channels/#monitoring-channels", 
            "text": "Most of the time your communication channel is open and passing dnp3 traffic back and forth. Sometimes, however, things can go wrong with your network or you have mis-configured your connection. when\ncreating your channel, you can pass in a shared_ptr  to monitor the state of channel. This interface provides a method returning an enumeration of the states of the channel:  enum class ChannelState : uint8_t\n{\n    /// offline and idle\n    CLOSED = 0,\n    /// trying to open\n    OPENING = 1,\n    /// open\n    OPEN = 2,\n    /// stopped and will never do anything again\n    SHUTDOWN = 3\n};", 
            "title": "Monitoring channels"
        }, 
        {
            "location": "/api/channels/#cleaning-up-channels", 
            "text": "Channels and all the sessions bound to them are automatically cleaned up when the DNP3Manager goes out of scope\n(or is deleted if allocated dynamically). You can manually remove a channel without having to stop every master or outstation bound\nto it by calling  IChannel::Shutdown() .  // permanently shutdown the channel\nchannel- Shutdown();  Calls to Shutdown() are idempotent. The resources for the underlying channel will be freed\nwhen you drop the reference to the shared_ptr.", 
            "title": "Cleaning up channels"
        }, 
        {
            "location": "/api/tls/", 
            "text": "Transport Layer Security (TLS)\n\n\nTLS support as provided by added two additional channel types, TLSServer and TLSClient.\n\n\nThese overloaded methods on \nDNP3Manager\n take an additional configuration parameter TLSConfig.\n\n\nThe opendnp3 TLS implementation only allows mutually authenticated connections using client certificates. Each side must provide 3 items:\n\n\n\n\nA certificate (either self-signed or root certificate) that will be used to authenticate the peer certificate.\n\n\nA local certificate to send to the peer.\n\n\nA private key corresponding to the public key in the local certificate used to authenticate.\n\n\n\n\nAll keys and certificates should be provided in the PEM format.", 
            "title": "TLS Support"
        }, 
        {
            "location": "/api/tls/#transport-layer-security-tls", 
            "text": "TLS support as provided by added two additional channel types, TLSServer and TLSClient.  These overloaded methods on  DNP3Manager  take an additional configuration parameter TLSConfig.  The opendnp3 TLS implementation only allows mutually authenticated connections using client certificates. Each side must provide 3 items:   A certificate (either self-signed or root certificate) that will be used to authenticate the peer certificate.  A local certificate to send to the peer.  A private key corresponding to the public key in the local certificate used to authenticate.   All keys and certificates should be provided in the PEM format.", 
            "title": "Transport Layer Security (TLS)"
        }, 
        {
            "location": "/api/linklayer/", 
            "text": "About\n\n\nThe DNP3 link-layer is the lowest level of the DNP3 stack, and provides a number of services for DNP3 communications:\n\n\n\n\nAddressing - Each DNP3 frame contains both a 16-bit \nsource\n and \ndestination\n address field.\n\n\nKeep-alive - The ability to periodically send \"keep-alive\" requests (REQUEST_LINK_STATUS)\n\n\nError-checking - Interleaved CRC values that can separately detect data corruption in the header and payload.\n\n\n\n\nConfiguration\n\n\nBoth master and outstation sessions require link-layer configuration.\n\n\nThe \nMasterStackConfig\n and \nOutstationStackConfig\n configuration structures each contain a \nLinkConfig\n structure. \nThis gives you access to the link-layer parameters when creating a master or outstation session.\n\n\nMasterStackConfig stackConfig;      // could also be OutstationStackConfig for an outstation\n\n// configure master specific parameters\n......  \n\n// set link-layer parameters\nstackConfig.link.LocalAddr = 1;     // the address of the master\nstackConfig.link.RemoteAddr = 10;   // the address of the remote outstation\n\n\n\n\nNot having the link-layer Local/Remote addresses configured correctly is the most frequent source of communication problems.\n Opendnp3 example applications\nautomatically talk to each other using a master address of 1 and an outstation address of 1024. There is no standard default address.\n\n\nKeep-alives\n\n\nThe link-layer will send a keep-alive request whenever it hasn't received a message from the other side of the link within the \nLinkConfig.KeepAliveTimeout\n parameter. \nThis configurable parameter defaults to 1 minute.  It is generally only needed for quiescent TCP operations, and can be disabled for other types of configurations. It is an \nindispensable parameter for polled outstations that act as TCP servers. Writing to a socket is the only way to detect dead/half-open sockets.\n\n\nILinkListener\n\n\nThe \nIMasterApplication\n and \nIOutstationApplication\n interfaces inherit from \nILinkListener\n. You can monitor important events at the link-layer by overriding the \ndefault methods on this interface.\n\n\nclass ILinkListener\n{\npublic:\n\n    /// Called when a the reset/unreset status of the link layer changes\n    virtual void OnStateChange(LinkStatus value) {}\n\n    /// Called when the keep alive timer elapses. This doesn't denote a keep-alive failure, it's just a notification\n    virtual void OnKeepAliveInitiated() {}\n\n    /// Called when a keep alive message (request link status) receives no response\n    virtual void OnKeepAliveFailure() {}\n\n    /// Called when a keep alive message receives a valid response\n    virtual void OnKeepAliveSuccess() {}\n};\n\n\n\n\nThe DNP3 specification details specific actions the master or outstation should take (like closing a TCP session and reconnecting) when keep-alive failures occur. \nOpendnp3 does not automatically perform these actions. User-code is expected to monitor this callback interface and take appropriate actions based on the type of communication\nchannel in use.", 
            "title": "Link-Layer"
        }, 
        {
            "location": "/api/linklayer/#about", 
            "text": "The DNP3 link-layer is the lowest level of the DNP3 stack, and provides a number of services for DNP3 communications:   Addressing - Each DNP3 frame contains both a 16-bit  source  and  destination  address field.  Keep-alive - The ability to periodically send \"keep-alive\" requests (REQUEST_LINK_STATUS)  Error-checking - Interleaved CRC values that can separately detect data corruption in the header and payload.", 
            "title": "About"
        }, 
        {
            "location": "/api/linklayer/#configuration", 
            "text": "Both master and outstation sessions require link-layer configuration.  The  MasterStackConfig  and  OutstationStackConfig  configuration structures each contain a  LinkConfig  structure. \nThis gives you access to the link-layer parameters when creating a master or outstation session.  MasterStackConfig stackConfig;      // could also be OutstationStackConfig for an outstation\n\n// configure master specific parameters\n......  \n\n// set link-layer parameters\nstackConfig.link.LocalAddr = 1;     // the address of the master\nstackConfig.link.RemoteAddr = 10;   // the address of the remote outstation  Not having the link-layer Local/Remote addresses configured correctly is the most frequent source of communication problems.  Opendnp3 example applications\nautomatically talk to each other using a master address of 1 and an outstation address of 1024. There is no standard default address.", 
            "title": "Configuration"
        }, 
        {
            "location": "/api/linklayer/#keep-alives", 
            "text": "The link-layer will send a keep-alive request whenever it hasn't received a message from the other side of the link within the  LinkConfig.KeepAliveTimeout  parameter. \nThis configurable parameter defaults to 1 minute.  It is generally only needed for quiescent TCP operations, and can be disabled for other types of configurations. It is an \nindispensable parameter for polled outstations that act as TCP servers. Writing to a socket is the only way to detect dead/half-open sockets.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/api/linklayer/#ilinklistener", 
            "text": "The  IMasterApplication  and  IOutstationApplication  interfaces inherit from  ILinkListener . You can monitor important events at the link-layer by overriding the \ndefault methods on this interface.  class ILinkListener\n{\npublic:\n\n    /// Called when a the reset/unreset status of the link layer changes\n    virtual void OnStateChange(LinkStatus value) {}\n\n    /// Called when the keep alive timer elapses. This doesn't denote a keep-alive failure, it's just a notification\n    virtual void OnKeepAliveInitiated() {}\n\n    /// Called when a keep alive message (request link status) receives no response\n    virtual void OnKeepAliveFailure() {}\n\n    /// Called when a keep alive message receives a valid response\n    virtual void OnKeepAliveSuccess() {}\n};  The DNP3 specification details specific actions the master or outstation should take (like closing a TCP session and reconnecting) when keep-alive failures occur. \nOpendnp3 does not automatically perform these actions. User-code is expected to monitor this callback interface and take appropriate actions based on the type of communication\nchannel in use.", 
            "title": "ILinkListener"
        }, 
        {
            "location": "/api/masters/", 
            "text": "Creating a master\n\n\nA master in opendnp3 is a component that communicates with a single outstation via a communication channel. You may see this term used in other places to refer to a\ncollection of such components communicating with multiple outstations. When more than one master is bound to a single communication channel, it is called a\n\nmulti-drop configuration\n.  This refers to the way in which an RS-485 serial network is chained from device to device. Opendnp3 will let you add multiple\nmasters / outstations to any communication channel, regardless of he underlying transport. You could even bind a master to a TCP server and reverse the\nnormal connection direction.\n\n\nTo add a master to a communication channel you call the \nAddMaster(...)\n method on the channel interface:\n\n\n// Contains static configuration for the master, and transport/link layers\nMasterStackConfig stackConfig;\n\n// you can optionally override these defaults like setting the application layer response timeout\n// or change behaviors on the master\nstackConfig.master.responseTimeout = TimeDuration::Seconds(2);\nstackConfig.master.disableUnsolOnStartup = true;\n\n// ... or you can override the default link layer settings\nstackConfig.link.LocalAddr = 1;\nstackConfig.link.RemoteAddr = 10;\n\nauto master = channel-\nAddMaster(\n  \nmaster\n,                                       // alias for logging\n  PrintingSOEHandler::Create(),                   // ISOEHandler (interface)\n  asiodnp3::DefaultMasterApplication::Create(),   // IMasterApplication (interface)\n  stackConfig                                     // static stack configuration\n);\n\n// enable the master - you can also Disable() it or Shutdown() permanently\nmaster-\nEnable();\n\n\n\n\n\nISOEHandler\n\n\nNote the 2nd parameter in the call to \nAddMaster(...)\n. This is the user-defined interface used to receive measurement data\nthat the master has received from the outstation. SOE stands for \nSequence of Events\n. SOE is a common term in SCADA circles\nthat is synonymous with \"the order in which things happened\".\n\n\nclass ISOEHandler : public ITransactable\n{\npublic:\n\n    virtual void Process(const HeaderInfo\n info, const ICollection\nIndexed\nBinary\n values) = 0;\n\n    // more Process methods for types like Analog, Counter, etc ....\n}\n\n\n\n\nAn ISOEHandler is just an interface with an overloaded \nProcess\n method for every measurement type in DNP3. It also inherits\n\nStart()\n and \nEnd()\n methods from ITransactable. This allows you tell when the master begins and ends parsing a received\nASDU that contains measurement data. You'll see this Start/End pattern with other interfaces in opendnp3.\n\n\nThe \nPrintingSOEHandler\n in the snippet where we added the master is just a singleton that prints measurement values to the console.\nYou'll definitely want to write your own implementation so that you can write to file, database, or display on your application in some\nfashion. The PrintingSOEHandler just extracts the measurement values from the ICollection like the following:\n\n\nvoid Process(const HeaderInfo\n info, const ICollection\nIndexed\nBinary\n values)\n{\n    auto print = [](const Indexed\nBinary\n pair) {\n        std::cout \n \n[\n \n pair.index \n \n] : \n \n pair.value \n std::endl;\n    };\n    values.ForeachItem(print);\n}\n\n\n\n\nThere's also a wealth of information in the \nHeaderInfo\n object including:\n\n\n\n\nThe specific group/variation associated with this ASDU header\n\n\nThe QualifierCode associated with this header\n\n\nAn enumeration describing the validity of the time-stamp for convenience to the programmer.\n\n\nThe index of the header within the ASDU\n\n\n\n\nRemember that the callbacks for the ISOEHandler methods come from the thread-pool.\n Depending on the number of sessions, you may not\nwant to block the stack in these callbacks. You might consider allocating some kind of object that is passed to a worker thread\nto actually write the data to disk/database.\n\n\nIMasterApplication\n\n\nThe 3rd parameter in the call to \nAddMaster(...)\n is a user-defined interface called \nIMasterApplication\n. It contains\ninherits from two sub-interfaces \nILinkListener\n and \nIUTCTimeSource\n as well as adding a number of methods that are\nmaster specific.\n\n\nYou can see all the methods you can override in the code documentation, but the most important ones are:\n\n\n\n\n\n\nvoid IOnReceiveIIN(const IINField\n iin)\n - Notifies you whenever an ASDU is received containing an internal indication field\n (IIN field). This allow you to log and react to specific error bits returned by the device.\n\n\n\n\n\n\nvoid OnTaskComplete(const TaskInfo\n info)\n - Tell you about tasks that are built into the master succeeding/failing. This callback\nis usually used to assess the \"health\" of the session.\n\n\n\n\n\n\nThe ILinkListener interface is also used on IOutstationApplication and is described in its own section.\n\n\nMasterStackConfig\n\n\nThe final parameter passed into \nAddMaster(...)\n is configuration struct that consists of link-layer configuration\ninformation and static configuration that defines that masters behavior. The link-layer config is also used for outstations,\nand is described in its own section.\n\n\nMasterParams\n\n\nEach of the dozen or so fields in this struct control certain automated behaviors within the master. Refer to the code documentation\nfor complete descriptions. This struct controls behaviors like:\n\n\n\n\nThe default response timeout\n\n\nWhether to perform unsolicited disable/enable on start-up\n\n\nWhether to perform automatic time synchronization if requested\n\n\nThe maximum Tx/Rx ASDU size which always default to 2K as per the DNP3 specification\n\n\n\n\nIMaster\n\n\nWhen you added a master to the channel, the channel returned an \nIMaster\n interface. This interface provides all access to a number of operations\non the master. Refer to the code documentation for specifics. Some examples are:\n\n\n\n\nAdd periodic scans to the master like exception (Class 1/2/3) and integrity scans (Class 1/2/3/0)\n\n\nScanning for specific ranges or event counts\n\n\nThe \nICommandProcessor\n sub-interface allow you to do \nSelectBeforeOperate\n and \nDirectOperate\n requests w/ CROBs and Analog Outputs\n\n\n\n\nICommandProcessor\n\n\nThis is a sub-interface that allows you to perform \nselect-before-operate\n and \ndirect-operate\n commands.\n\n\nclass ICommandProcessor\n{\npublic:\n    virtual void SelectAndOperate(...params...) = 0;\n    virtual void DirectOperate(...params...) = 0;\n};\n\n\n\n\nOpendnp3 supports multiple commands per request on both the master and the outstation, however, for convenience there are overloaded\nmethods to issue a single command of each type . You can use these overloads or build a \nCommandSet\n, which is a collection of headers.\n\n\nCommandSet commands;\n\n\n\n\nThe easiest way to define headers is to use initializer_lists, but you can also create a specific header type\nand then add entries in a loop.\n\n\n// CROB to be sent to two indices\nControlRelayOutputBlock crob(ControlCode::LATCH_ON);\n\n// Use initializer list to create a header in a single call - Send LATCH_ON to indices 0 and 1\ncommands.Add\nControlRelayOutputBlock\n({ WithIndex(crob, 0), WithIndex(crob, 1) });\n\n/// Add two analog outputs to the set using the header method.\n/// Note that the 'header' is captured as a reference.\nauto\n header = commands.StartHeader\nAnalogOutputInt16\n();\nheader.Add(AnalogOutputInt16(7), 3);\nheader.Add(AnalogOutputInt16(9), 4);\n\n\n\n\nYou pass the command set into the master using one of the ICommandProcessor methods.\n\n\npMaster-\nSelectAndOperate(std::move(commands), callback);\n\n\n\n\nBut what is the \ncallback\n? It's just a lambda expression or std::function that accepts \nICommandTaskResult\n\nas its single argument.\n\n\nauto callback = [](const ICommandTaskResult\n result) -\n void\n{           \n    std::cout \n \nSummary: \n \n TaskCompletionToString(result.summary) \n std::endl;\n    auto print = [](const CommandPointResult\n res)\n    {\n        std::cout\n            \n \nHeader: \n \n res.headerIndex\n            \n \n Index: \n \n res.index\n            \n \n State: \n \n CommandPointStateToString(res.state)\n            \n \n Status: \n \n CommandStatusToString(res.status);\n    };\n    result.ForeachItem(print);\n};\n\n\n\n\nThe example above prints the summary value for the task, and information about the success or failure of each of the commands you specified in the CommandSet. Since we sent 4 individual command values, the handler would print something the following on a fully successful response:\n\n\nSummary: SUCCESS\nHeader: 0 Index: 0 State: SUCCESS Status: SUCCESS\nHeader: 0 Index: 1 State: SUCCESS Status: SUCCESS\nHeader: 1 Index: 3 State: SUCCESS Status: SUCCESS\nHeader: 1 Index: 4 State: SUCCESS Status: SUCCESS\n\n\n\n\nImporant:\n Even if the summary \nTaskCompletion\n value is SUCCESS, this doesn't mean that every command you sent was successful. It just means that the master got back some response that was parsed successfully. You must check the result for each command you sent individually. DNP3 allows for truncated responses if the outstation doesn't understand everything you sent. A possible response might be:\n\n\nSummary: SUCCESS\nHeader: 0 Index: 0 State: SUCCESS Status: SUCCESS\nHeader: 0 Index: 1 State: SUCCESS Status: SUCCESS\nHeader: 1 Index: 3 State: SUCCESS Status: NOT_SUPPORTED\nHeader: 1 Index: 4 State: INIT Status: UNDEFINED\n\n\n\n\nNote that you \nalways\n get an entry for every command you specified, even if there's no response at all because the connection is down.\n\n\nSummary: FAILURE_NO_COMMS\nHeader: 0 Index: 0 State: INIT Status: UNDEFINED\nHeader: 0 Index: 1 State: INIT Status: UNDEFINED\nHeader: 1 Index: 3 State: INIT Status: UNDEFINED\nHeader: 1 Index: 4 State: INIT Status: UNDEFINED\n\n\n\n\nRefer to the Doxygen docs for detailed information about each enum type:\n\n\n\n\nTaskCompletion - The summary value for the task\n\n\nCommandPointState - The various result states for each command point.\n\n\nCommandStatus - The command status enumeration defined in the spec. Only valid for some states.\n\n\n\n\nCleaning Up\n\n\nCalls to Shutdown() are idempotent. The master will be permanently deleted once all references to the shared_ptr\n have been dropped.", 
            "title": "Masters"
        }, 
        {
            "location": "/api/masters/#creating-a-master", 
            "text": "A master in opendnp3 is a component that communicates with a single outstation via a communication channel. You may see this term used in other places to refer to a\ncollection of such components communicating with multiple outstations. When more than one master is bound to a single communication channel, it is called a multi-drop configuration .  This refers to the way in which an RS-485 serial network is chained from device to device. Opendnp3 will let you add multiple\nmasters / outstations to any communication channel, regardless of he underlying transport. You could even bind a master to a TCP server and reverse the\nnormal connection direction.  To add a master to a communication channel you call the  AddMaster(...)  method on the channel interface:  // Contains static configuration for the master, and transport/link layers\nMasterStackConfig stackConfig;\n\n// you can optionally override these defaults like setting the application layer response timeout\n// or change behaviors on the master\nstackConfig.master.responseTimeout = TimeDuration::Seconds(2);\nstackConfig.master.disableUnsolOnStartup = true;\n\n// ... or you can override the default link layer settings\nstackConfig.link.LocalAddr = 1;\nstackConfig.link.RemoteAddr = 10;\n\nauto master = channel- AddMaster(\n   master ,                                       // alias for logging\n  PrintingSOEHandler::Create(),                   // ISOEHandler (interface)\n  asiodnp3::DefaultMasterApplication::Create(),   // IMasterApplication (interface)\n  stackConfig                                     // static stack configuration\n);\n\n// enable the master - you can also Disable() it or Shutdown() permanently\nmaster- Enable();", 
            "title": "Creating a master"
        }, 
        {
            "location": "/api/masters/#isoehandler", 
            "text": "Note the 2nd parameter in the call to  AddMaster(...) . This is the user-defined interface used to receive measurement data\nthat the master has received from the outstation. SOE stands for  Sequence of Events . SOE is a common term in SCADA circles\nthat is synonymous with \"the order in which things happened\".  class ISOEHandler : public ITransactable\n{\npublic:\n\n    virtual void Process(const HeaderInfo  info, const ICollection Indexed Binary  values) = 0;\n\n    // more Process methods for types like Analog, Counter, etc ....\n}  An ISOEHandler is just an interface with an overloaded  Process  method for every measurement type in DNP3. It also inherits Start()  and  End()  methods from ITransactable. This allows you tell when the master begins and ends parsing a received\nASDU that contains measurement data. You'll see this Start/End pattern with other interfaces in opendnp3.  The  PrintingSOEHandler  in the snippet where we added the master is just a singleton that prints measurement values to the console.\nYou'll definitely want to write your own implementation so that you can write to file, database, or display on your application in some\nfashion. The PrintingSOEHandler just extracts the measurement values from the ICollection like the following:  void Process(const HeaderInfo  info, const ICollection Indexed Binary  values)\n{\n    auto print = [](const Indexed Binary  pair) {\n        std::cout    [    pair.index    ] :     pair.value   std::endl;\n    };\n    values.ForeachItem(print);\n}  There's also a wealth of information in the  HeaderInfo  object including:   The specific group/variation associated with this ASDU header  The QualifierCode associated with this header  An enumeration describing the validity of the time-stamp for convenience to the programmer.  The index of the header within the ASDU   Remember that the callbacks for the ISOEHandler methods come from the thread-pool.  Depending on the number of sessions, you may not\nwant to block the stack in these callbacks. You might consider allocating some kind of object that is passed to a worker thread\nto actually write the data to disk/database.", 
            "title": "ISOEHandler"
        }, 
        {
            "location": "/api/masters/#imasterapplication", 
            "text": "The 3rd parameter in the call to  AddMaster(...)  is a user-defined interface called  IMasterApplication . It contains\ninherits from two sub-interfaces  ILinkListener  and  IUTCTimeSource  as well as adding a number of methods that are\nmaster specific.  You can see all the methods you can override in the code documentation, but the most important ones are:    void IOnReceiveIIN(const IINField  iin)  - Notifies you whenever an ASDU is received containing an internal indication field\n (IIN field). This allow you to log and react to specific error bits returned by the device.    void OnTaskComplete(const TaskInfo  info)  - Tell you about tasks that are built into the master succeeding/failing. This callback\nis usually used to assess the \"health\" of the session.    The ILinkListener interface is also used on IOutstationApplication and is described in its own section.", 
            "title": "IMasterApplication"
        }, 
        {
            "location": "/api/masters/#masterstackconfig", 
            "text": "The final parameter passed into  AddMaster(...)  is configuration struct that consists of link-layer configuration\ninformation and static configuration that defines that masters behavior. The link-layer config is also used for outstations,\nand is described in its own section.", 
            "title": "MasterStackConfig"
        }, 
        {
            "location": "/api/masters/#masterparams", 
            "text": "Each of the dozen or so fields in this struct control certain automated behaviors within the master. Refer to the code documentation\nfor complete descriptions. This struct controls behaviors like:   The default response timeout  Whether to perform unsolicited disable/enable on start-up  Whether to perform automatic time synchronization if requested  The maximum Tx/Rx ASDU size which always default to 2K as per the DNP3 specification", 
            "title": "MasterParams"
        }, 
        {
            "location": "/api/masters/#imaster", 
            "text": "When you added a master to the channel, the channel returned an  IMaster  interface. This interface provides all access to a number of operations\non the master. Refer to the code documentation for specifics. Some examples are:   Add periodic scans to the master like exception (Class 1/2/3) and integrity scans (Class 1/2/3/0)  Scanning for specific ranges or event counts  The  ICommandProcessor  sub-interface allow you to do  SelectBeforeOperate  and  DirectOperate  requests w/ CROBs and Analog Outputs", 
            "title": "IMaster"
        }, 
        {
            "location": "/api/masters/#icommandprocessor", 
            "text": "This is a sub-interface that allows you to perform  select-before-operate  and  direct-operate  commands.  class ICommandProcessor\n{\npublic:\n    virtual void SelectAndOperate(...params...) = 0;\n    virtual void DirectOperate(...params...) = 0;\n};  Opendnp3 supports multiple commands per request on both the master and the outstation, however, for convenience there are overloaded\nmethods to issue a single command of each type . You can use these overloads or build a  CommandSet , which is a collection of headers.  CommandSet commands;  The easiest way to define headers is to use initializer_lists, but you can also create a specific header type\nand then add entries in a loop.  // CROB to be sent to two indices\nControlRelayOutputBlock crob(ControlCode::LATCH_ON);\n\n// Use initializer list to create a header in a single call - Send LATCH_ON to indices 0 and 1\ncommands.Add ControlRelayOutputBlock ({ WithIndex(crob, 0), WithIndex(crob, 1) });\n\n/// Add two analog outputs to the set using the header method.\n/// Note that the 'header' is captured as a reference.\nauto  header = commands.StartHeader AnalogOutputInt16 ();\nheader.Add(AnalogOutputInt16(7), 3);\nheader.Add(AnalogOutputInt16(9), 4);  You pass the command set into the master using one of the ICommandProcessor methods.  pMaster- SelectAndOperate(std::move(commands), callback);  But what is the  callback ? It's just a lambda expression or std::function that accepts  ICommandTaskResult \nas its single argument.  auto callback = [](const ICommandTaskResult  result) -  void\n{           \n    std::cout    Summary:     TaskCompletionToString(result.summary)   std::endl;\n    auto print = [](const CommandPointResult  res)\n    {\n        std::cout\n               Header:     res.headerIndex\n                Index:     res.index\n                State:     CommandPointStateToString(res.state)\n                Status:     CommandStatusToString(res.status);\n    };\n    result.ForeachItem(print);\n};  The example above prints the summary value for the task, and information about the success or failure of each of the commands you specified in the CommandSet. Since we sent 4 individual command values, the handler would print something the following on a fully successful response:  Summary: SUCCESS\nHeader: 0 Index: 0 State: SUCCESS Status: SUCCESS\nHeader: 0 Index: 1 State: SUCCESS Status: SUCCESS\nHeader: 1 Index: 3 State: SUCCESS Status: SUCCESS\nHeader: 1 Index: 4 State: SUCCESS Status: SUCCESS  Imporant:  Even if the summary  TaskCompletion  value is SUCCESS, this doesn't mean that every command you sent was successful. It just means that the master got back some response that was parsed successfully. You must check the result for each command you sent individually. DNP3 allows for truncated responses if the outstation doesn't understand everything you sent. A possible response might be:  Summary: SUCCESS\nHeader: 0 Index: 0 State: SUCCESS Status: SUCCESS\nHeader: 0 Index: 1 State: SUCCESS Status: SUCCESS\nHeader: 1 Index: 3 State: SUCCESS Status: NOT_SUPPORTED\nHeader: 1 Index: 4 State: INIT Status: UNDEFINED  Note that you  always  get an entry for every command you specified, even if there's no response at all because the connection is down.  Summary: FAILURE_NO_COMMS\nHeader: 0 Index: 0 State: INIT Status: UNDEFINED\nHeader: 0 Index: 1 State: INIT Status: UNDEFINED\nHeader: 1 Index: 3 State: INIT Status: UNDEFINED\nHeader: 1 Index: 4 State: INIT Status: UNDEFINED  Refer to the Doxygen docs for detailed information about each enum type:   TaskCompletion - The summary value for the task  CommandPointState - The various result states for each command point.  CommandStatus - The command status enumeration defined in the spec. Only valid for some states.", 
            "title": "ICommandProcessor"
        }, 
        {
            "location": "/api/masters/#cleaning-up", 
            "text": "Calls to Shutdown() are idempotent. The master will be permanently deleted once all references to the shared_ptr  have been dropped.", 
            "title": "Cleaning Up"
        }, 
        {
            "location": "/api/outstations/", 
            "text": "Creating an outstation\n\n\nAn outstation in opendnp3 is a component that communicates with a single master via a communication channel. It makes measurements of the physical world and then\nsends them to a master upon request (solicited) or on its own accord (unsolicited). Occasionally a master requests that it do something by sending it a control.\nJust like a master, an outstation can be attached to any communication channel that opendnp3 supports.\n\n\nTo add an outstation to a communication channel you call the \nAddOutstation\n method on the channel interface:\n\n\nOutstationStackConfig stackConfig;\n\n// You must specify the shape of your database and the size of the event buffers\nstackConfig.dbTemplate = DatabaseTemplate::AllTypes(10);\nstackConfig.outstation.eventBufferConfig = EventBufferConfig::AllTypes(10);\n\n// you can override an default outstation parameters here\nstackConfig.outstation.params.allowUnsolicited = true;\n\n// You can override the default link layer settings here\n// in this example we've changed the default link layer addressing\nstackConfig.link.LocalAddr = 10;\nstackConfig.link.RemoteAddr = 1;\n\nauto outstation = channel-\nAddOutstation(\n  \noutstation\n,                             // alias for logging\n  SuccessCommandHandler::Create(),          // ICommandHandler (interface)\n  DefaultOutstationApplication::Create(),   // IOutstationApplication (interface)\n  stackConfig                               // static stack configuration\n);\n\noutstation-\nEnable();\n\n\n\n\nUpdateBuilder\n\n\nWhen a new measurement is read from an input or a new value is received from a downstream protocol, you need to update the corresponding\nvalue in the outstation. This is accomplished with the \nUpdateBuilder\n and corresponding \nUpdates\n class.\n\n\nUpdateBuilder builder;\nbuilder.Update(Counter(state.count), 0);\nbuilder.Update(Analog(state.value), 0);\n// ... update more types and indices\n\n// finalize the set of updates\nauto updates = builder.Build();\n\n// apply the updates to one or more outstations\noutstation-\napply(updates);\n\n\n\n\nThe update is atomic. All of the updated values are applied to the outstation database and event buffers at the same time. The \nUpdates\n instance\nreturned from UpdateBuilder::Build() can be safely sent to any number of outstation instances. The outstation automatically decides if these updates \nproduce \nevents\n. How events are detected are defined within the DNP3 standard, and varies from type to type. Analogs and counters can use \n\ndeadbands\n to ensure that unimportant changes are not reported.\n\n\nICommandHandler\n\n\nWhen the outstation receives a control request, it dispatches individual commands in the message to the ICommandhandler interface\nsupplied when the outstation was added to the channel.\n\n\nclass ICommandHandler : public ITransactable\n{\n    virtual CommandStatus Select(const ControlRelayOutputBlock\n command, uint16_t index) = 0;\n    virtual CommandStatus Operate(const ControlRelayOutputBlock\n command, uint16_t index, OperateType opType) = 0;\n    /// ... additional methods for the 4 types of analog outputs - Group 41Var[1-4]\n}\n\n\n\n\nYou'll notice that the interface is \ntransactable\n meaning that it has Start()/End() methods just like the \nISOEHandler\n interface in the master. ASDUs\ncan contain multiple controls in a single object header, and possibly multiple headers. The Start()/End() methods tell you when an ASDU containing\ncommands begins and ends. Many applications probably don't care, but this knowledge is there if you need it for some reason.\n\n\nThe \nSelect\n operation shouldn't actually perform the command. Think of it as a question along the lines of \n\"Is this operation supported?\"\n.\n\nSelect-Before-Operate\n (SBO) is an artifact of the days before the SCADA community really trusted CRCs. It's a 2-pass control scheme where the\noutstation verifies that the select/operate are identical. It was intended as an additional protection against data corruption on noisy networks.\n\n\nThe \nOperate\n method is called from a successful SBO sequence or from a \nDirectOperate\n or \nDirectOperateNoAck\n request. Many applications don't care how the\nrequest came in, but the \nOperateType optype\n parameter provides an enumeration that can be used to reject certain operations or to forward the same mode downstream in\ngateway applications.\n\n\nenum class OperateType : uint8_t\n{\n  /// The outstation received a valid prior SELECT followed by OPERATE\n  SelectBeforeOperate = 0x0,\n  /// The outstation received a direct operate request\n  DirectOperate = 0x1,\n  /// The outstation received a direct operate no ack request\n  DirectOperateNoAck = 0x2\n};\n\n\n\n\nCommandStatus\n\n\nYou must immediately return a \nCommandStatus\n enumeration value in response to each callback. This callback should never block.\n\n\nenum class CommandStatus : uint8_t\n{\n  /// command was accepted, initiated, or queued\n  SUCCESS = 0,\n  /// command timed out before completing\n  TIMEOUT = 1,\n  /// command requires being selected before operate, configuration issue\n  NO_SELECT = 2,\n  /// more values ...\n}\n\n\n\n\nThe enumeration contains about ~18 different values, and you should refer to 1815 or the code comments for a description of each. In general,\nyou'll be choosing \nSUCCESS\n or some kind of error code.\n\n\nIt's important to understand that \nSUCCESS\n doesn't imply that the command was synchronously executed. It really just means that the command\nwas received and queued. Some devices can synchronously process a command, e.g. quickly writing to memory mapped I/O, but you'd never\nwant to block in a gateway application to perform a downstream Modbus transaction. You'd pass the control of to another thread or queue the operation\nin some way for subsequent processing.", 
            "title": "Outstations"
        }, 
        {
            "location": "/api/outstations/#creating-an-outstation", 
            "text": "An outstation in opendnp3 is a component that communicates with a single master via a communication channel. It makes measurements of the physical world and then\nsends them to a master upon request (solicited) or on its own accord (unsolicited). Occasionally a master requests that it do something by sending it a control.\nJust like a master, an outstation can be attached to any communication channel that opendnp3 supports.  To add an outstation to a communication channel you call the  AddOutstation  method on the channel interface:  OutstationStackConfig stackConfig;\n\n// You must specify the shape of your database and the size of the event buffers\nstackConfig.dbTemplate = DatabaseTemplate::AllTypes(10);\nstackConfig.outstation.eventBufferConfig = EventBufferConfig::AllTypes(10);\n\n// you can override an default outstation parameters here\nstackConfig.outstation.params.allowUnsolicited = true;\n\n// You can override the default link layer settings here\n// in this example we've changed the default link layer addressing\nstackConfig.link.LocalAddr = 10;\nstackConfig.link.RemoteAddr = 1;\n\nauto outstation = channel- AddOutstation(\n   outstation ,                             // alias for logging\n  SuccessCommandHandler::Create(),          // ICommandHandler (interface)\n  DefaultOutstationApplication::Create(),   // IOutstationApplication (interface)\n  stackConfig                               // static stack configuration\n);\n\noutstation- Enable();", 
            "title": "Creating an outstation"
        }, 
        {
            "location": "/api/outstations/#updatebuilder", 
            "text": "When a new measurement is read from an input or a new value is received from a downstream protocol, you need to update the corresponding\nvalue in the outstation. This is accomplished with the  UpdateBuilder  and corresponding  Updates  class.  UpdateBuilder builder;\nbuilder.Update(Counter(state.count), 0);\nbuilder.Update(Analog(state.value), 0);\n// ... update more types and indices\n\n// finalize the set of updates\nauto updates = builder.Build();\n\n// apply the updates to one or more outstations\noutstation- apply(updates);  The update is atomic. All of the updated values are applied to the outstation database and event buffers at the same time. The  Updates  instance\nreturned from UpdateBuilder::Build() can be safely sent to any number of outstation instances. The outstation automatically decides if these updates \nproduce  events . How events are detected are defined within the DNP3 standard, and varies from type to type. Analogs and counters can use  deadbands  to ensure that unimportant changes are not reported.", 
            "title": "UpdateBuilder"
        }, 
        {
            "location": "/api/outstations/#icommandhandler", 
            "text": "When the outstation receives a control request, it dispatches individual commands in the message to the ICommandhandler interface\nsupplied when the outstation was added to the channel.  class ICommandHandler : public ITransactable\n{\n    virtual CommandStatus Select(const ControlRelayOutputBlock  command, uint16_t index) = 0;\n    virtual CommandStatus Operate(const ControlRelayOutputBlock  command, uint16_t index, OperateType opType) = 0;\n    /// ... additional methods for the 4 types of analog outputs - Group 41Var[1-4]\n}  You'll notice that the interface is  transactable  meaning that it has Start()/End() methods just like the  ISOEHandler  interface in the master. ASDUs\ncan contain multiple controls in a single object header, and possibly multiple headers. The Start()/End() methods tell you when an ASDU containing\ncommands begins and ends. Many applications probably don't care, but this knowledge is there if you need it for some reason.  The  Select  operation shouldn't actually perform the command. Think of it as a question along the lines of  \"Is this operation supported?\" . Select-Before-Operate  (SBO) is an artifact of the days before the SCADA community really trusted CRCs. It's a 2-pass control scheme where the\noutstation verifies that the select/operate are identical. It was intended as an additional protection against data corruption on noisy networks.  The  Operate  method is called from a successful SBO sequence or from a  DirectOperate  or  DirectOperateNoAck  request. Many applications don't care how the\nrequest came in, but the  OperateType optype  parameter provides an enumeration that can be used to reject certain operations or to forward the same mode downstream in\ngateway applications.  enum class OperateType : uint8_t\n{\n  /// The outstation received a valid prior SELECT followed by OPERATE\n  SelectBeforeOperate = 0x0,\n  /// The outstation received a direct operate request\n  DirectOperate = 0x1,\n  /// The outstation received a direct operate no ack request\n  DirectOperateNoAck = 0x2\n};", 
            "title": "ICommandHandler"
        }, 
        {
            "location": "/api/outstations/#commandstatus", 
            "text": "You must immediately return a  CommandStatus  enumeration value in response to each callback. This callback should never block.  enum class CommandStatus : uint8_t\n{\n  /// command was accepted, initiated, or queued\n  SUCCESS = 0,\n  /// command timed out before completing\n  TIMEOUT = 1,\n  /// command requires being selected before operate, configuration issue\n  NO_SELECT = 2,\n  /// more values ...\n}  The enumeration contains about ~18 different values, and you should refer to 1815 or the code comments for a description of each. In general,\nyou'll be choosing  SUCCESS  or some kind of error code.  It's important to understand that  SUCCESS  doesn't imply that the command was synchronously executed. It really just means that the command\nwas received and queued. Some devices can synchronously process a command, e.g. quickly writing to memory mapped I/O, but you'd never\nwant to block in a gateway application to perform a downstream Modbus transaction. You'd pass the control of to another thread or queue the operation\nin some way for subsequent processing.", 
            "title": "CommandStatus"
        }, 
        {
            "location": "/troubleshooting/troubleshooting/", 
            "text": "Common Problems\n\n\nThis section serves as a bit of a FAQ for common issues and their resolutions.\n\n\nUnable to find \"asio.hpp\"\n\n\nYou need to tell CMake where the ASIO headers are located. Please review the \ncmake instructions\n.\n\n\nUnable to load DNP3CLRAdapter or one of its dependencies\n\n\n.NET does not provide useful error messages when an assembly can't find a native dependency. The .NET\nbindings depend on the Visual C++ Runtime library for the version of visual studio you used to build them.\n\n\nThese packages can be found from Microsoft by searching for \"visual studio c++ runtime\" in your favorite search engine.\n\n\nYou might also see this error because CLRAdapter can't find openssl (libeay32.dll / libssl32.dll) if your bindings didn't have\nthese linked statically. The solution is to make sure openssl is installed in the correct system location.\n\n\nMaster or Outstation doesn't detect an ethernet cable being unplugged\n\n\nThere is no way through the standard socket API to detect this, other than trying to write data to the socket. This means that if\nmaster or outstation sessions are quiescent (meaning that they don't write data periodically), you should be using the link-layer\n\nkeep-alive feature\n to ensure that dead/hung connections are appropriately detected.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/troubleshooting/troubleshooting/#common-problems", 
            "text": "This section serves as a bit of a FAQ for common issues and their resolutions.  Unable to find \"asio.hpp\"  You need to tell CMake where the ASIO headers are located. Please review the  cmake instructions .  Unable to load DNP3CLRAdapter or one of its dependencies  .NET does not provide useful error messages when an assembly can't find a native dependency. The .NET\nbindings depend on the Visual C++ Runtime library for the version of visual studio you used to build them.  These packages can be found from Microsoft by searching for \"visual studio c++ runtime\" in your favorite search engine.  You might also see this error because CLRAdapter can't find openssl (libeay32.dll / libssl32.dll) if your bindings didn't have\nthese linked statically. The solution is to make sure openssl is installed in the correct system location.  Master or Outstation doesn't detect an ethernet cable being unplugged  There is no way through the standard socket API to detect this, other than trying to write data to the socket. This means that if\nmaster or outstation sessions are quiescent (meaning that they don't write data periodically), you should be using the link-layer keep-alive feature  to ensure that dead/hung connections are appropriately detected.", 
            "title": "Common Problems"
        }, 
        {
            "location": "/contributing/tasks/", 
            "text": "Formatting the code\n\n\nThere is a cmake \"format\" task available in every build system. It requires\nhaving \nAstyle\n on your path.\n\n\nFormatting the license\n\n\nThere is a maven POM with a plugin to do this. From the root directory:\n\n\n mvn -f formatHeaders.xml license:format\n\n\n\n\nGetting code coverage\n\n\nYou can build the libraries and exes with gcov support\n\n\n cmake -DSTATICLIBS=ON -DCOVERAGE=ON -DCMAKE_BUILD_TYPE=Debug\n\n make\n\n\n\n\nThen run the test suites to output coverage information.\n\n\n ./testopendnp3\n\n ./testopenpal\n\n\n\n\nThen generate an info file with lcov\n\n\n lcov -c -d ./ -b ./ -o coverage.info\n\n\n\n\nand then process this into html\n\n\n genhtml coverage.info -o test_html", 
            "title": "Common Tasks"
        }, 
        {
            "location": "/contributing/tasks/#formatting-the-code", 
            "text": "There is a cmake \"format\" task available in every build system. It requires\nhaving  Astyle  on your path.", 
            "title": "Formatting the code"
        }, 
        {
            "location": "/contributing/tasks/#formatting-the-license", 
            "text": "There is a maven POM with a plugin to do this. From the root directory:   mvn -f formatHeaders.xml license:format", 
            "title": "Formatting the license"
        }, 
        {
            "location": "/contributing/tasks/#getting-code-coverage", 
            "text": "You can build the libraries and exes with gcov support   cmake -DSTATICLIBS=ON -DCOVERAGE=ON -DCMAKE_BUILD_TYPE=Debug  make  Then run the test suites to output coverage information.   ./testopendnp3  ./testopenpal  Then generate an info file with lcov   lcov -c -d ./ -b ./ -o coverage.info  and then process this into html   genhtml coverage.info -o test_html", 
            "title": "Getting code coverage"
        }
    ]
}