{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to OpenDNP3, a portable, rigorously-tested, Apache-licensed implementation of the DNP3 protocol (aka IEEE-1815). Warning DNP3 is a complex protocol with many subtle rules. This guide and the OpenDNP3 project cannot cover everything about the protocol. To successfully use OpenDNP3 or develop a product based on it, you will almost certainly need a copy of the specification. We recommend that your organization joins DNP.org to obtain a copy. Important Links Project Homepage - The official project homepage. Github Repository - You'll find the tagged releases here as well as the development branches. Google Group - Post questions and receive updates. Free support is provided as time permits. DNP Users Group - The official DNP3 user group. Join and get a copy of the standard. Getting Support If you need dedicated commercial support, custom integration services, or compliance/security testing contact Automatak . If the library does not contain a feature that you need for your device or application, please consider sponsoring the addition.","title":"Introduction"},{"location":"#important-links","text":"Project Homepage - The official project homepage. Github Repository - You'll find the tagged releases here as well as the development branches. Google Group - Post questions and receive updates. Free support is provided as time permits. DNP Users Group - The official DNP3 user group. Join and get a copy of the standard.","title":"Important Links"},{"location":"#getting-support","text":"If you need dedicated commercial support, custom integration services, or compliance/security testing contact Automatak . If the library does not contain a feature that you need for your device or application, please consider sponsoring the addition.","title":"Getting Support"},{"location":"api/architecture/","text":"All opendnp3 programs begin by creating a DNP3Manager . Creating this object allocates a thread pool used to process events and callbacks to user code. // Create a root DNP3 manager with a single thread that logs to the console DNP3Manager manager ( 1 , ConsoleLogger :: Create ()); If you're familiar with using ASIO in other contexts, than it should be no surprise that the DNP3Manager owns an asio::io_context . It also has a thread pool for calling asio::io_context::run() , however, this is an internal detail that most opendnp3 programmers do not need to know to use the stack. How many threads you allocate to your thread pool can be a subtle matter. On simple systems like a small outstation that only talks to a single master, one thread is sufficient. For masters that may talk to hundreds or thousands of outstations, you'll want to scale your thread-pool to the number of logical processors on your machine. // Create a root DNP3 manager as many threads as logical processors DNP3Manager manager ( std :: hardware_concurrency (), ConsoleLogger :: Create ()); Warning You should avoid blocking during callbacks made to user code, as there are a limited number of threads in the thread pool and this can drastically decrease performance. This advice is especially critical for large systems where the number of communication channels greatly outnumbers the number of threads in the pool. If all of your threads are blocked then other channels can't do useful work like sending control requests to the field. Blocking operations should be done in separate threads. If you must design your system to do some blocking operations without handling other threads, you can mitigate this problem by scaling the number of threads in the pool as a multiple of the number of cores. // Create a root DNP3 manager with twice as many threads as logical processors DNP3Manager manager ( 2 * std :: hardware_concurrency (), ConsoleLogger :: Create ()); Properly configuring your thread pool ensures optimal performance. Channels & Sessions Communication channels are created from the root DNP3Manager class. // Create a TCP client channel to which we can bind masters or outstations auto channel = manager . AddTCPClient (... arguments ...); There is a unique method for adding each supported channel type, TCPClient , TCPServer , TLSClient , TLSServer , or Serial . You should refer to code documentation for a description of the parameters. With your channels created you can now bind master or outstations sessions to your them. Binding multiple master or outstations sessions to a single channel is a multi-drop configuration. // Create a master bound to a particular channel auto master = channel -> AddMaster (... arguments ...); // Create an outstation bound to particular channel auto outstation = channel -> AddOutstation (... arguments ...); Architecture Each channel and the sessions bound to it are asynchronous state-machines. During execution, ASIO guarantees that each channel is only processing one event at a time from a single thread. This means that there is no explicit thread synchronization required anywhere in the stack. When user code wants to communicate with a stack, e.g. load measurement data into an outstation or request that a command be initiated on a master, it gets \"posted\" to the correct channel's executor. This ensures that each channel and all the sessions bound to it are only ever touched by a single thread at a time. User code, however, may need to worry about multi-threading. If you hand the same callback interface to multiple sessions, you will potentially receive callbacks from multiple threads simultaneously on the same interface.","title":"Architecture"},{"location":"api/architecture/#channels-sessions","text":"Communication channels are created from the root DNP3Manager class. // Create a TCP client channel to which we can bind masters or outstations auto channel = manager . AddTCPClient (... arguments ...); There is a unique method for adding each supported channel type, TCPClient , TCPServer , TLSClient , TLSServer , or Serial . You should refer to code documentation for a description of the parameters. With your channels created you can now bind master or outstations sessions to your them. Binding multiple master or outstations sessions to a single channel is a multi-drop configuration. // Create a master bound to a particular channel auto master = channel -> AddMaster (... arguments ...); // Create an outstation bound to particular channel auto outstation = channel -> AddOutstation (... arguments ...);","title":"Channels &amp; Sessions"},{"location":"api/architecture/#architecture","text":"Each channel and the sessions bound to it are asynchronous state-machines. During execution, ASIO guarantees that each channel is only processing one event at a time from a single thread. This means that there is no explicit thread synchronization required anywhere in the stack. When user code wants to communicate with a stack, e.g. load measurement data into an outstation or request that a command be initiated on a master, it gets \"posted\" to the correct channel's executor. This ensures that each channel and all the sessions bound to it are only ever touched by a single thread at a time. User code, however, may need to worry about multi-threading. If you hand the same callback interface to multiple sessions, you will potentially receive callbacks from multiple threads simultaneously on the same interface.","title":"Architecture"},{"location":"api/channels/","text":"The library uses abstract communication channels to send and receive bytes \"over the wire\". The following channel types are supported: TCP client / server TLS client / server UDP Serial The manager that you created previously is now ready to have some channels bound to it. Adding a channel to the manager does not make it attempt to open the channel immediately. If it's a TCP socket or serial port it won't try to open until you bind at least one outstation or master session and enable it. Here's an example of how you go about adding a TCP client. Assume we have a DNP3Manager called 'manager': auto channel = manager . AddTCPClient ( // alias used in log messages \"tcpclient\" , // bitfield used to filter what gets logged levels :: NORMAL | levels :: ALL_APP_COMMS , // determines how connections will be retried ChannelRetry :: Default (), // List of endpoints or DNS host names to cycle through { IPEndpoint ( \"127.0.0.1\" , 20000 ) }, // IP address of the local ethernet adapter (0.0.0.0 == any adapter) \"0.0.0.0\" , // optional listener interface for monitoring the channel PrintingChannelListener :: Create (), ); There is a Add<channel type> method on DNP3Manager for each channel type. Refer to the C++ doxygen documentation for details. Exponential back-off The ChannelRetry configuration specifies two timing parameters for the minimum and maximum connection retry times using an exponential back-off strategy. If you don't want exponential back-off, just set the minimum and maximum to the same value for a consistent delay. Exponential back-off really only makes sense for initiating TCP connections. For instance if you set the minimum to TimeDuration::Seconds(3) and the maximum to TimeDuration::Seconds(40) a series of failed connections would have the following time gaps between attempts. 3, 6, 12, 24, 40, 40, ..... Monitoring channels Most of the time your communication channel is open and passing dnp3 traffic back and forth. Sometimes, however, things can go wrong with your network or you have mis-configured your connection. when creating your channel, you can pass in a shared_ptr<IChannelListener> to monitor the state of channel. This interface provides a method returning an enumeration of the states of the channel: enum class ChannelState : uint8_t { /// offline and idle CLOSED = 0 , /// trying to open OPENING = 1 , /// open OPEN = 2 , /// stopped and will never do anything again SHUTDOWN = 3 }; Cleaning up Channels and all the sessions bound to them are automatically cleaned up when the DNP3Manager goes out of scope (or is deleted if allocated dynamically). You can manually remove a channel without having to stop every master or outstation bound to it by calling IChannel::Shutdown() . // permanently shutdown the channel channel -> Shutdown (); Calls to Shutdown() are idempotent. The resources for the underlying channel will be freed when you drop the reference to the shared_ptr<IChannel> .","title":"Channels"},{"location":"api/channels/#exponential-back-off","text":"The ChannelRetry configuration specifies two timing parameters for the minimum and maximum connection retry times using an exponential back-off strategy. If you don't want exponential back-off, just set the minimum and maximum to the same value for a consistent delay. Exponential back-off really only makes sense for initiating TCP connections. For instance if you set the minimum to TimeDuration::Seconds(3) and the maximum to TimeDuration::Seconds(40) a series of failed connections would have the following time gaps between attempts. 3, 6, 12, 24, 40, 40, .....","title":"Exponential back-off"},{"location":"api/channels/#monitoring-channels","text":"Most of the time your communication channel is open and passing dnp3 traffic back and forth. Sometimes, however, things can go wrong with your network or you have mis-configured your connection. when creating your channel, you can pass in a shared_ptr<IChannelListener> to monitor the state of channel. This interface provides a method returning an enumeration of the states of the channel: enum class ChannelState : uint8_t { /// offline and idle CLOSED = 0 , /// trying to open OPENING = 1 , /// open OPEN = 2 , /// stopped and will never do anything again SHUTDOWN = 3 };","title":"Monitoring channels"},{"location":"api/channels/#cleaning-up","text":"Channels and all the sessions bound to them are automatically cleaned up when the DNP3Manager goes out of scope (or is deleted if allocated dynamically). You can manually remove a channel without having to stop every master or outstation bound to it by calling IChannel::Shutdown() . // permanently shutdown the channel channel -> Shutdown (); Calls to Shutdown() are idempotent. The resources for the underlying channel will be freed when you drop the reference to the shared_ptr<IChannel> .","title":"Cleaning up"},{"location":"api/linklayer/","text":"The DNP3 link-layer is the lowest level of the DNP3 stack, and provides a number of services for DNP3 communications: Addressing - Each DNP3 frame contains both a 16-bit source and destination address field. Keep-alive - The ability to periodically send \"keep-alive\" requests ( REQUEST_LINK_STATUS ) Error-checking - Interleaved CRC values that can separately detect data corruption in the header and payload. Configuration Both master and outstation sessions require link-layer configuration. The MasterStackConfig and OutstationStackConfig configuration structures each contain a LinkConfig structure. This gives you access to the link-layer parameters when creating a master or outstation session. MasterStackConfig stackConfig ; // could also be OutstationStackConfig for an outstation // configure master specific parameters ...... // set link-layer parameters stackConfig . link . LocalAddr = 1 ; // the address of the master stackConfig . link . RemoteAddr = 10 ; // the address of the remote outstation Important Not having the link-layer Local/Remote addresses configured correctly is the most frequent source of communication problems. Opendnp3 example applications automatically talk to each other using a master address of 1 and an outstation address of 1024. There is no standard default address. Keep-alives The link-layer will send a keep-alive request whenever it hasn't received a message from the other side of the link within the LinkConfig.KeepAliveTimeout parameter. This configurable parameter defaults to 1 minute. It is generally only needed for quiescent TCP operations, and can be disabled for other types of configurations. It is an indispensable parameter for polled outstations that act as TCP servers. Writing to a socket is the only way to detect dead/half-open sockets. ILinkListener The IMasterApplication and IOutstationApplication interfaces inherit from ILinkListener . You can monitor important events at the link-layer by overriding the default methods on this interface. class ILinkListener { public : /// Called when a the reset/unreset status of the link layer changes virtual void OnStateChange ( LinkStatus value ) {} /// Called when the keep alive timer elapses. This doesn't denote a keep-alive failure, it's just a notification virtual void OnKeepAliveInitiated () {} /// Called when a keep alive message (request link status) receives no response virtual void OnKeepAliveFailure () {} /// Called when a keep alive message receives a valid response virtual void OnKeepAliveSuccess () {} }; The DNP3 specification details specific actions the master or outstation should take (like closing a TCP session and reconnecting) when keep-alive failures occur. Opendnp3 does not automatically perform these actions. User-code is expected to monitor this callback interface and take appropriate actions based on the type of communication channel in use.","title":"Link-Layer"},{"location":"api/linklayer/#configuration","text":"Both master and outstation sessions require link-layer configuration. The MasterStackConfig and OutstationStackConfig configuration structures each contain a LinkConfig structure. This gives you access to the link-layer parameters when creating a master or outstation session. MasterStackConfig stackConfig ; // could also be OutstationStackConfig for an outstation // configure master specific parameters ...... // set link-layer parameters stackConfig . link . LocalAddr = 1 ; // the address of the master stackConfig . link . RemoteAddr = 10 ; // the address of the remote outstation Important Not having the link-layer Local/Remote addresses configured correctly is the most frequent source of communication problems. Opendnp3 example applications automatically talk to each other using a master address of 1 and an outstation address of 1024. There is no standard default address.","title":"Configuration"},{"location":"api/linklayer/#keep-alives","text":"The link-layer will send a keep-alive request whenever it hasn't received a message from the other side of the link within the LinkConfig.KeepAliveTimeout parameter. This configurable parameter defaults to 1 minute. It is generally only needed for quiescent TCP operations, and can be disabled for other types of configurations. It is an indispensable parameter for polled outstations that act as TCP servers. Writing to a socket is the only way to detect dead/half-open sockets.","title":"Keep-alives"},{"location":"api/linklayer/#ilinklistener","text":"The IMasterApplication and IOutstationApplication interfaces inherit from ILinkListener . You can monitor important events at the link-layer by overriding the default methods on this interface. class ILinkListener { public : /// Called when a the reset/unreset status of the link layer changes virtual void OnStateChange ( LinkStatus value ) {} /// Called when the keep alive timer elapses. This doesn't denote a keep-alive failure, it's just a notification virtual void OnKeepAliveInitiated () {} /// Called when a keep alive message (request link status) receives no response virtual void OnKeepAliveFailure () {} /// Called when a keep alive message receives a valid response virtual void OnKeepAliveSuccess () {} }; The DNP3 specification details specific actions the master or outstation should take (like closing a TCP session and reconnecting) when keep-alive failures occur. Opendnp3 does not automatically perform these actions. User-code is expected to monitor this callback interface and take appropriate actions based on the type of communication channel in use.","title":"ILinkListener"},{"location":"api/logging/","text":"Listening You can bind to the opendnp3 log stream by calling passing a shared_ptr<ILogHandler> into the DNP3Manager constructor. This interface just has a single method: class ILogHandler { public : /** * Callback method for log messages * * @param module ModuleId of the logger * @param id string id of the logger * @param level bitfield LogLevel of the logger * @param location location in the source of the log call * @param message message of the log call */ void log ( ModuleId module , const char * id , LogLevel level , char const * location , char const * message ) = 0 ; }; If you need to send log messages to more than one location, create your own proxy ILogHandler . Keep in mind that this is a callback from the thread-pool and will block that thread from executing. A good strategy for a file-logger in a big system would be to send a message to a worker thread to write the message to disk using a synchronized queue that only blocks when it reaches a maximum size. Individual loggers Each channel and stack instance (master or outstation) has its own logger whose log level can be individually configured and adjusted at run-time. This allows you to increase the log level of a particular channel or stack, without receiving full protocol analysis for everything and grinding the system to a halt. You specify the initial log level for each channel when it is created and this is inherited by stacks on that channel. You can adjust it during execute by calling IChannel::SetLogFilters , IMaster::SetLogFilters , or IOutstation::SetLogFilters . Log levels Opendnp3 defines a number of typical log levels like DEBUG, INFO, WARN, ERR. In addition it defines a number of log levels specific to the protocol dissection and analysis. Turning on all the various DNP3 analysis levels allows you to create useful communication traces like the following. ms ( 1440709781929 ) <-TL-- outstation - FIR: 1 FIN: 1 SEQ: 0 LEN: 11 ms ( 1440709781932 ) <-AL-- outstation - C0 15 3C 02 06 3C 03 06 3C 04 06 ms ( 1440709781934 ) <-AL-- outstation - FIR: 1 FIN: 1 CON: 0 UNS: 0 SEQ: 0 FUNC: DISABLE_UNSOLICITED ms ( 1440709781939 ) <-AL-- outstation - 060 ,002 - Class Data - Class 1 - all objects ms ( 1440709781944 ) <-AL-- outstation - 060 ,003 - Class Data - Class 2 - all objects ms ( 1440709781949 ) <-AL-- outstation - 060 ,004 - Class Data - Class 3 - all objects","title":"Logging"},{"location":"api/logging/#listening","text":"You can bind to the opendnp3 log stream by calling passing a shared_ptr<ILogHandler> into the DNP3Manager constructor. This interface just has a single method: class ILogHandler { public : /** * Callback method for log messages * * @param module ModuleId of the logger * @param id string id of the logger * @param level bitfield LogLevel of the logger * @param location location in the source of the log call * @param message message of the log call */ void log ( ModuleId module , const char * id , LogLevel level , char const * location , char const * message ) = 0 ; }; If you need to send log messages to more than one location, create your own proxy ILogHandler . Keep in mind that this is a callback from the thread-pool and will block that thread from executing. A good strategy for a file-logger in a big system would be to send a message to a worker thread to write the message to disk using a synchronized queue that only blocks when it reaches a maximum size.","title":"Listening"},{"location":"api/logging/#individual-loggers","text":"Each channel and stack instance (master or outstation) has its own logger whose log level can be individually configured and adjusted at run-time. This allows you to increase the log level of a particular channel or stack, without receiving full protocol analysis for everything and grinding the system to a halt. You specify the initial log level for each channel when it is created and this is inherited by stacks on that channel. You can adjust it during execute by calling IChannel::SetLogFilters , IMaster::SetLogFilters , or IOutstation::SetLogFilters .","title":"Individual loggers"},{"location":"api/logging/#log-levels","text":"Opendnp3 defines a number of typical log levels like DEBUG, INFO, WARN, ERR. In addition it defines a number of log levels specific to the protocol dissection and analysis. Turning on all the various DNP3 analysis levels allows you to create useful communication traces like the following. ms ( 1440709781929 ) <-TL-- outstation - FIR: 1 FIN: 1 SEQ: 0 LEN: 11 ms ( 1440709781932 ) <-AL-- outstation - C0 15 3C 02 06 3C 03 06 3C 04 06 ms ( 1440709781934 ) <-AL-- outstation - FIR: 1 FIN: 1 CON: 0 UNS: 0 SEQ: 0 FUNC: DISABLE_UNSOLICITED ms ( 1440709781939 ) <-AL-- outstation - 060 ,002 - Class Data - Class 1 - all objects ms ( 1440709781944 ) <-AL-- outstation - 060 ,003 - Class Data - Class 2 - all objects ms ( 1440709781949 ) <-AL-- outstation - 060 ,004 - Class Data - Class 3 - all objects","title":"Log levels"},{"location":"api/masters/","text":"Creating a master A master in opendnp3 is a component that communicates with a single outstation via a communication channel. You may see this term used in other places to refer to a collection of such components communicating with multiple outstations. When more than one master is bound to a single communication channel, it is called a multi-drop configuration. This refers to the way in which an RS-485 serial network is chained from device to device. Opendnp3 will let you add multiple masters / outstations to any communication channel, regardless of he underlying transport. You could even bind a master to a TCP server and reverse the normal connection direction. To add a master to a communication channel you call the AddMaster(...) method on the channel interface: // Contains static configuration for the master, and transport/link layers MasterStackConfig stackConfig ; // you can optionally override these defaults like setting the application layer response timeout // or change behaviors on the master stackConfig . master . responseTimeout = TimeDuration :: Seconds ( 2 ); stackConfig . master . disableUnsolOnStartup = true ; // ... or you can override the default link layer settings stackConfig . link . LocalAddr = 1 ; stackConfig . link . RemoteAddr = 10 ; auto master = channel -> AddMaster ( \"master\" , // alias for logging PrintingSOEHandler :: Create (), // ISOEHandler (interface) DefaultMasterApplication :: Create (), // IMasterApplication (interface) stackConfig // static stack configuration ); // enable the master - you can also Disable() it or Shutdown() permanently master -> Enable (); ISOEHandler Note the 2nd parameter in the call to AddMaster(...) . This is the user-defined interface used to receive measurement data that the master has received from the outstation. SOE stands for \"Sequence of Events\". SOE is a common term in SCADA circles that is synonymous with \"the order in which things occured\". class ISOEHandler { public : virtual void BeginFragment ( const ResponseInfo & info ) = 0 ; virtual void EndFragment ( const ResponseInfo & info ) = 0 ; virtual void Process ( const HeaderInfo & info , const ICollection < Indexed < Binary >>& values ) = 0 ; // more Process methods for types like Analog, Counter, etc .... } An ISOEHandler is just an interface with an overloaded Process method for every measurement type in DNP3 It also includes BeginFragment and EndFragment methods which can be used to tell when the processing of a response starts and ends. The PrintingSOEHandler in the snippet where we added the master is just a simple instance which prints values to the console. You'll definitely want to write your own implementation so that you can write to file, database, or display on your application in some fashion. The PrintingSOEHandler just extracts the measurement values from the ICollection like the following: void Process ( const HeaderInfo & info , const ICollection < Indexed < Binary >>& values ) { auto print = [] (const Indexed<Binary>& pair) { std : : cout << \" [ \" << pair.index << \" ] : \" << pair . value << std :: endl ; } ; values . ForeachItem ( print ); } There's also a wealth of information in the HeaderInfo object including: The specific group/variation associated with this ASDU header The QualifierCode associated with this header An enumeration describing the validity of the time-stamp for convenience to the programmer. The index of the header within the ASDU Important Remember that the callbacks for the ISOEHandler methods come from the thread-pool. Depending on the number of sessions, you may not want to block the stack in these callbacks. You might consider allocating some kind of object that is passed to a worker thread to actually write the data to disk/database. IMasterApplication The 3rd parameter in the call to AddMaster(...) is a user-defined interface called IMasterApplication . It inherits from two sub-interfaces ILinkListener and IUTCTimeSource as well as adding a number of methods that are master specific. You can see all the methods you can override in the code documentation, but the most important ones are: void IOnReceiveIIN(const IINField& iin) - Notifies you whenever an ASDU is received containing an internal indication field (IIN field). This allow you to log and react to specific error bits returned by the device. void OnTaskComplete(const TaskInfo& info) - Tell you about tasks that are built into the master succeeding/failing. This callback is usually used to assess the \"health\" of the session. The ILinkListener interface is also used on IOutstationApplication and is described in its own section . MasterStackConfig The final parameter passed into AddMaster(...) is a configuration struct that consists of link-layer configuration information and static configuration that defines the masters behavior. The link-layer config is also used for outstations, and is described in its own section . MasterParams Each of the dozen or so fields in this struct control certain automated behaviors within the master. Refer to the code documentation for complete descriptions. This struct controls behaviors like: The default response timeout Whether to perform unsolicited disable/enable on start-up Whether to perform automatic time synchronization if requested The maximum Tx/Rx ASDU size which always default to 2K as per the DNP3 specification IMaster When a master is added to a channel, the channel returns an IMaster interface. This interface provides all access to a number of operations on the master. Refer to the code documentation for specifics. Some examples are: Add periodic scans to the master like exception (Class 1/2/3) and integrity scans (Class 1/2/3/0) Scanning for specific ranges or event counts The ICommandProcessor sub-interface allow you to do SelectBeforeOperate and DirectOperate requests w/ CROBs and Analog Outputs ICommandProcessor This is a sub-interface that allows you to perform \"select-before-operate\" and \"direct operate\" commands. class ICommandProcessor { public : virtual void SelectAndOperate (... params ...) = 0 ; virtual void DirectOperate (... params ...) = 0 ; }; Opendnp3 supports multiple commands per request on both the master and the outstation, however, for convenience there are overloaded methods to issue a single command of each type . You can use these overloads or build a CommandSet , which is a collection of headers. CommandSet commands ; The easiest way to define headers is to use initializer_lists, but you can also create a specific header type and then add entries in a loop. // CROB to be sent to two indices ControlRelayOutputBlock crob ( ControlCode :: LATCH_ON ); // Use initializer list to create a header in a single call - Send LATCH_ON to indices 0 and 1 commands . Add < ControlRelayOutputBlock > ({ WithIndex ( crob , 0 ), WithIndex ( crob , 1 ) }); /// Add two analog outputs to the set using the header method. /// Note that the 'header' is captured as a reference. auto & header = commands . StartHeader < AnalogOutputInt16 > (); header . Add ( AnalogOutputInt16 ( 7 ), 3 ); header . Add ( AnalogOutputInt16 ( 9 ), 4 ); You pass the command set into the master using one of the ICommandProcessor methods. master -> SelectAndOperate ( std :: move ( commands ), callback ); The callback is a lambda expression or std::function that accepts ICommandTaskResult as its single argument. auto callback = [] ( const ICommandTaskResult & result ) - > void { std : : cout << \"Summary: \" << TaskCompletionToString ( result . summary ) << std :: endl ; auto print = [] (const CommandPointResult& res) { std : : cout << \"Header: \" << res . headerIndex << \" Index: \" << res . index << \" State: \" << CommandPointStateToString ( res . state ) << \" Status: \" << CommandStatusToString ( res . status ); } ; result . ForeachItem ( print ); } ; The example above prints the summary value for the task, and information about the success or failure of each of the commands you specified in the CommandSet. Since we sent 4 individual command values, the handler would print something the following on a fully successful response: Summary: SUCCESS Header: 0 Index: 0 State: SUCCESS Status: SUCCESS Header: 0 Index: 1 State: SUCCESS Status: SUCCESS Header: 1 Index: 3 State: SUCCESS Status: SUCCESS Header: 1 Index: 4 State: SUCCESS Status: SUCCESS Imporant Even if the summary TaskCompletion value is SUCCESS, this doesn't mean that every command you sent was successful. It just means that the master got back some response that was parsed successfully. You must check the result for each command you sent individually. DNP3 allows for truncated responses if the outstation doesn't understand everything you sent. A possible response might be: Summary: SUCCESS Header: 0 Index: 0 State: SUCCESS Status: SUCCESS Header: 0 Index: 1 State: SUCCESS Status: SUCCESS Header: 1 Index: 3 State: SUCCESS Status: NOT_SUPPORTED Header: 1 Index: 4 State: INIT Status: UNDEFINED Note that you always get an entry for every command you specified, even if there's no response at all because the connection is down. Summary: FAILURE_NO_COMMS Header: 0 Index: 0 State: INIT Status: UNDEFINED Header: 0 Index: 1 State: INIT Status: UNDEFINED Header: 1 Index: 3 State: INIT Status: UNDEFINED Header: 1 Index: 4 State: INIT Status: UNDEFINED Refer to the Doxygen docs for detailed information about each enum type: TaskCompletion - The summary value for the task CommandPointState - The various result states for each command point. CommandStatus - The command status enumeration defined in the spec. Only valid for some states. Cleaning Up Calls to Shutdown() are idempotent. The master will be permanently deleted once all references to the shared_ptr<IMaster> have been dropped.","title":"Masters"},{"location":"api/masters/#creating-a-master","text":"A master in opendnp3 is a component that communicates with a single outstation via a communication channel. You may see this term used in other places to refer to a collection of such components communicating with multiple outstations. When more than one master is bound to a single communication channel, it is called a multi-drop configuration. This refers to the way in which an RS-485 serial network is chained from device to device. Opendnp3 will let you add multiple masters / outstations to any communication channel, regardless of he underlying transport. You could even bind a master to a TCP server and reverse the normal connection direction. To add a master to a communication channel you call the AddMaster(...) method on the channel interface: // Contains static configuration for the master, and transport/link layers MasterStackConfig stackConfig ; // you can optionally override these defaults like setting the application layer response timeout // or change behaviors on the master stackConfig . master . responseTimeout = TimeDuration :: Seconds ( 2 ); stackConfig . master . disableUnsolOnStartup = true ; // ... or you can override the default link layer settings stackConfig . link . LocalAddr = 1 ; stackConfig . link . RemoteAddr = 10 ; auto master = channel -> AddMaster ( \"master\" , // alias for logging PrintingSOEHandler :: Create (), // ISOEHandler (interface) DefaultMasterApplication :: Create (), // IMasterApplication (interface) stackConfig // static stack configuration ); // enable the master - you can also Disable() it or Shutdown() permanently master -> Enable ();","title":"Creating a master"},{"location":"api/masters/#isoehandler","text":"Note the 2nd parameter in the call to AddMaster(...) . This is the user-defined interface used to receive measurement data that the master has received from the outstation. SOE stands for \"Sequence of Events\". SOE is a common term in SCADA circles that is synonymous with \"the order in which things occured\". class ISOEHandler { public : virtual void BeginFragment ( const ResponseInfo & info ) = 0 ; virtual void EndFragment ( const ResponseInfo & info ) = 0 ; virtual void Process ( const HeaderInfo & info , const ICollection < Indexed < Binary >>& values ) = 0 ; // more Process methods for types like Analog, Counter, etc .... } An ISOEHandler is just an interface with an overloaded Process method for every measurement type in DNP3 It also includes BeginFragment and EndFragment methods which can be used to tell when the processing of a response starts and ends. The PrintingSOEHandler in the snippet where we added the master is just a simple instance which prints values to the console. You'll definitely want to write your own implementation so that you can write to file, database, or display on your application in some fashion. The PrintingSOEHandler just extracts the measurement values from the ICollection like the following: void Process ( const HeaderInfo & info , const ICollection < Indexed < Binary >>& values ) { auto print = [] (const Indexed<Binary>& pair) { std : : cout << \" [ \" << pair.index << \" ] : \" << pair . value << std :: endl ; } ; values . ForeachItem ( print ); } There's also a wealth of information in the HeaderInfo object including: The specific group/variation associated with this ASDU header The QualifierCode associated with this header An enumeration describing the validity of the time-stamp for convenience to the programmer. The index of the header within the ASDU Important Remember that the callbacks for the ISOEHandler methods come from the thread-pool. Depending on the number of sessions, you may not want to block the stack in these callbacks. You might consider allocating some kind of object that is passed to a worker thread to actually write the data to disk/database.","title":"ISOEHandler"},{"location":"api/masters/#imasterapplication","text":"The 3rd parameter in the call to AddMaster(...) is a user-defined interface called IMasterApplication . It inherits from two sub-interfaces ILinkListener and IUTCTimeSource as well as adding a number of methods that are master specific. You can see all the methods you can override in the code documentation, but the most important ones are: void IOnReceiveIIN(const IINField& iin) - Notifies you whenever an ASDU is received containing an internal indication field (IIN field). This allow you to log and react to specific error bits returned by the device. void OnTaskComplete(const TaskInfo& info) - Tell you about tasks that are built into the master succeeding/failing. This callback is usually used to assess the \"health\" of the session. The ILinkListener interface is also used on IOutstationApplication and is described in its own section .","title":"IMasterApplication"},{"location":"api/masters/#masterstackconfig","text":"The final parameter passed into AddMaster(...) is a configuration struct that consists of link-layer configuration information and static configuration that defines the masters behavior. The link-layer config is also used for outstations, and is described in its own section .","title":"MasterStackConfig"},{"location":"api/masters/#masterparams","text":"Each of the dozen or so fields in this struct control certain automated behaviors within the master. Refer to the code documentation for complete descriptions. This struct controls behaviors like: The default response timeout Whether to perform unsolicited disable/enable on start-up Whether to perform automatic time synchronization if requested The maximum Tx/Rx ASDU size which always default to 2K as per the DNP3 specification","title":"MasterParams"},{"location":"api/masters/#imaster","text":"When a master is added to a channel, the channel returns an IMaster interface. This interface provides all access to a number of operations on the master. Refer to the code documentation for specifics. Some examples are: Add periodic scans to the master like exception (Class 1/2/3) and integrity scans (Class 1/2/3/0) Scanning for specific ranges or event counts The ICommandProcessor sub-interface allow you to do SelectBeforeOperate and DirectOperate requests w/ CROBs and Analog Outputs","title":"IMaster"},{"location":"api/masters/#icommandprocessor","text":"This is a sub-interface that allows you to perform \"select-before-operate\" and \"direct operate\" commands. class ICommandProcessor { public : virtual void SelectAndOperate (... params ...) = 0 ; virtual void DirectOperate (... params ...) = 0 ; }; Opendnp3 supports multiple commands per request on both the master and the outstation, however, for convenience there are overloaded methods to issue a single command of each type . You can use these overloads or build a CommandSet , which is a collection of headers. CommandSet commands ; The easiest way to define headers is to use initializer_lists, but you can also create a specific header type and then add entries in a loop. // CROB to be sent to two indices ControlRelayOutputBlock crob ( ControlCode :: LATCH_ON ); // Use initializer list to create a header in a single call - Send LATCH_ON to indices 0 and 1 commands . Add < ControlRelayOutputBlock > ({ WithIndex ( crob , 0 ), WithIndex ( crob , 1 ) }); /// Add two analog outputs to the set using the header method. /// Note that the 'header' is captured as a reference. auto & header = commands . StartHeader < AnalogOutputInt16 > (); header . Add ( AnalogOutputInt16 ( 7 ), 3 ); header . Add ( AnalogOutputInt16 ( 9 ), 4 ); You pass the command set into the master using one of the ICommandProcessor methods. master -> SelectAndOperate ( std :: move ( commands ), callback ); The callback is a lambda expression or std::function that accepts ICommandTaskResult as its single argument. auto callback = [] ( const ICommandTaskResult & result ) - > void { std : : cout << \"Summary: \" << TaskCompletionToString ( result . summary ) << std :: endl ; auto print = [] (const CommandPointResult& res) { std : : cout << \"Header: \" << res . headerIndex << \" Index: \" << res . index << \" State: \" << CommandPointStateToString ( res . state ) << \" Status: \" << CommandStatusToString ( res . status ); } ; result . ForeachItem ( print ); } ; The example above prints the summary value for the task, and information about the success or failure of each of the commands you specified in the CommandSet. Since we sent 4 individual command values, the handler would print something the following on a fully successful response: Summary: SUCCESS Header: 0 Index: 0 State: SUCCESS Status: SUCCESS Header: 0 Index: 1 State: SUCCESS Status: SUCCESS Header: 1 Index: 3 State: SUCCESS Status: SUCCESS Header: 1 Index: 4 State: SUCCESS Status: SUCCESS Imporant Even if the summary TaskCompletion value is SUCCESS, this doesn't mean that every command you sent was successful. It just means that the master got back some response that was parsed successfully. You must check the result for each command you sent individually. DNP3 allows for truncated responses if the outstation doesn't understand everything you sent. A possible response might be: Summary: SUCCESS Header: 0 Index: 0 State: SUCCESS Status: SUCCESS Header: 0 Index: 1 State: SUCCESS Status: SUCCESS Header: 1 Index: 3 State: SUCCESS Status: NOT_SUPPORTED Header: 1 Index: 4 State: INIT Status: UNDEFINED Note that you always get an entry for every command you specified, even if there's no response at all because the connection is down. Summary: FAILURE_NO_COMMS Header: 0 Index: 0 State: INIT Status: UNDEFINED Header: 0 Index: 1 State: INIT Status: UNDEFINED Header: 1 Index: 3 State: INIT Status: UNDEFINED Header: 1 Index: 4 State: INIT Status: UNDEFINED Refer to the Doxygen docs for detailed information about each enum type: TaskCompletion - The summary value for the task CommandPointState - The various result states for each command point. CommandStatus - The command status enumeration defined in the spec. Only valid for some states.","title":"ICommandProcessor"},{"location":"api/masters/#cleaning-up","text":"Calls to Shutdown() are idempotent. The master will be permanently deleted once all references to the shared_ptr<IMaster> have been dropped.","title":"Cleaning Up"},{"location":"api/outstations/","text":"An outstation in opendnp3 is a component that communicates with a single master via a communication channel. It makes measurements of the physical world and then sends them to a master upon request (solicited) or on its own accord (unsolicited). Occasionally a master requests that it do something by sending it a control. Just like a master, an outstation can be attached to any communication channel that opendnp3 supports. To add an outstation to a communication channel you call the AddOutstation method on the channel interface: // default configuration w/ an empty database OutstationStackConfig config ; // configure database points config . database = DatabaseConfig ( 10 ); // 10 of each type with default settings // adjust some settings for analog 0 to non-default values config . database . analog_input [ 0 ]. clazz = PointClass :: Class2 ; config . database . analog_input [ 0 ]. svariation = StaticAnalogVariation :: Group30Var5 ; config . database . analog_input [ 0 ]. evariation = EventAnalogVariation :: Group32Var7 ; // configure the size of the event buffers config . outstation . eventBufferConfig = EventBufferConfig :: AllTypes ( 10 ); // you can override a default outstation parameters here config . outstation . params . allowUnsolicited = true ; // You can override the default link layer settings here // in this example we've changed the default link layer addressing config . link . LocalAddr = 10 ; config . link . RemoteAddr = 1 ; auto outstation = channel -> AddOutstation ( \"outstation\" , // alias for logging SuccessCommandHandler :: Create (), // ICommandHandler (interface) DefaultOutstationApplication :: Create (), // IOutstationApplication (interface) config // static stack configuration ); outstation -> Enable (); UpdateBuilder When a new measurement is read from an input or a new value is received from a downstream protocol, you need to update the corresponding value in the outstation. This is accomplished with the UpdateBuilder and corresponding Updates class. UpdateBuilder builder ; builder . Update ( Counter ( state . count ), 0 ); builder . Update ( Analog ( state . value ), 0 ); // ... update more types and indices // finalize the set of updates auto updates = builder . Build (); // apply the updates to one or more outstations outstation -> apply ( updates ); The update is atomic. All of the updated values are applied to the outstation database and event buffers at the same time. The Updates instance returned from UpdateBuilder::Build() can be safely sent to any number of outstation instances. The outstation automatically decides if these updates produce events. How events are detected are defined within the DNP3 standard, and varies from type to type. Analogs and counters can use deadbands to ensure that unimportant changes are not reported. ICommandHandler When the outstation receives a control request, it dispatches individual commands in the message to the ICommandhandler interface supplied when the outstation was added to the channel. class ICommandHandler { /** * called when a command APDU begins processing */ virtual void Begin () = 0 ; /** * called when a command APDU ends processing */ virtual void End () = 0 ; virtual CommandStatus Select ( const ControlRelayOutputBlock & command , uint16_t index ) = 0 ; virtual CommandStatus Operate ( const ControlRelayOutputBlock & command , uint16_t index , IUpdateHandler & handler , OperateType opType ) = 0 ; /// ... additional methods for the 4 types of analog outputs - Group 41Var[1-4] } The Begin()/End() methods tell you when an ASDU containing commands begins and ends. Many applications probably don't care, but this knowledge is there if you need it for some reason. The Select method shouldn't actually perform the command. Think of it as a question along the lines of \"Is this operation supported?\" . Select-Before-Operate (SBO) is an artifact of the days before the the CRC integrity checks were really truted. It's a 2-pass control scheme where the outstation verifies that the select/operate are identical. It was intended as an additional protection against data corruption on noisy transports like radio and modems. The Operate method is called from a successful SBO sequence or from a DirectOperate or DirectOperateNoAck request. Applications shouldn't care how the request came in, but the OperateType parameter provides an enumeration that can be used to reject certain operations or to forward the same mode downstream in gateway applications. enum class OperateType : uint8_t { /// The outstation received a valid prior SELECT followed by OPERATE SelectBeforeOperate = 0x0 , /// The outstation received a direct operate request DirectOperate = 0x1 , /// The outstation received a direct operate no ack request DirectOperateNoAck = 0x2 }; The IUpdateHandler provides the ability to update points as a direct result of the control. This is a convience since you would otherwise have to pass your implementation of ICommandHandler an instance of IOutstation after you create it. Frequently, implemenations want to mirror binary and analog output operations to binary output status and analog output status points directly in the handler. CommandStatus You must immediately return a CommandStatus enumeration value in response to each callback. This callback should never block . enum class CommandStatus : uint8_t { /// command was accepted, initiated, or queued SUCCESS = 0 , /// command timed out before completing TIMEOUT = 1 , /// command requires being selected before operate, configuration issue NO_SELECT = 2 , /// more values ... } The enumeration contains about ~18 different values, and you should refer to 1815 or the code comments for a description of each. In general, you'll be choosing SUCCESS or some kind of error code. It's important to understand that SUCCESS doesn't imply that the command was synchronously executed. It really just means that the command was received and queued. Some devices can synchronously process a command, e.g. quickly writing to memory mapped I/O, but you'd never want to block in a gateway application to perform a downstream Modbus transaction. You'd pass the control of to another thread or queue the operation in some way for subsequent processing.","title":"Outstations"},{"location":"api/outstations/#updatebuilder","text":"When a new measurement is read from an input or a new value is received from a downstream protocol, you need to update the corresponding value in the outstation. This is accomplished with the UpdateBuilder and corresponding Updates class. UpdateBuilder builder ; builder . Update ( Counter ( state . count ), 0 ); builder . Update ( Analog ( state . value ), 0 ); // ... update more types and indices // finalize the set of updates auto updates = builder . Build (); // apply the updates to one or more outstations outstation -> apply ( updates ); The update is atomic. All of the updated values are applied to the outstation database and event buffers at the same time. The Updates instance returned from UpdateBuilder::Build() can be safely sent to any number of outstation instances. The outstation automatically decides if these updates produce events. How events are detected are defined within the DNP3 standard, and varies from type to type. Analogs and counters can use deadbands to ensure that unimportant changes are not reported.","title":"UpdateBuilder"},{"location":"api/outstations/#icommandhandler","text":"When the outstation receives a control request, it dispatches individual commands in the message to the ICommandhandler interface supplied when the outstation was added to the channel. class ICommandHandler { /** * called when a command APDU begins processing */ virtual void Begin () = 0 ; /** * called when a command APDU ends processing */ virtual void End () = 0 ; virtual CommandStatus Select ( const ControlRelayOutputBlock & command , uint16_t index ) = 0 ; virtual CommandStatus Operate ( const ControlRelayOutputBlock & command , uint16_t index , IUpdateHandler & handler , OperateType opType ) = 0 ; /// ... additional methods for the 4 types of analog outputs - Group 41Var[1-4] } The Begin()/End() methods tell you when an ASDU containing commands begins and ends. Many applications probably don't care, but this knowledge is there if you need it for some reason. The Select method shouldn't actually perform the command. Think of it as a question along the lines of \"Is this operation supported?\" . Select-Before-Operate (SBO) is an artifact of the days before the the CRC integrity checks were really truted. It's a 2-pass control scheme where the outstation verifies that the select/operate are identical. It was intended as an additional protection against data corruption on noisy transports like radio and modems. The Operate method is called from a successful SBO sequence or from a DirectOperate or DirectOperateNoAck request. Applications shouldn't care how the request came in, but the OperateType parameter provides an enumeration that can be used to reject certain operations or to forward the same mode downstream in gateway applications. enum class OperateType : uint8_t { /// The outstation received a valid prior SELECT followed by OPERATE SelectBeforeOperate = 0x0 , /// The outstation received a direct operate request DirectOperate = 0x1 , /// The outstation received a direct operate no ack request DirectOperateNoAck = 0x2 }; The IUpdateHandler provides the ability to update points as a direct result of the control. This is a convience since you would otherwise have to pass your implementation of ICommandHandler an instance of IOutstation after you create it. Frequently, implemenations want to mirror binary and analog output operations to binary output status and analog output status points directly in the handler.","title":"ICommandHandler"},{"location":"api/outstations/#commandstatus","text":"You must immediately return a CommandStatus enumeration value in response to each callback. This callback should never block . enum class CommandStatus : uint8_t { /// command was accepted, initiated, or queued SUCCESS = 0 , /// command timed out before completing TIMEOUT = 1 , /// command requires being selected before operate, configuration issue NO_SELECT = 2 , /// more values ... } The enumeration contains about ~18 different values, and you should refer to 1815 or the code comments for a description of each. In general, you'll be choosing SUCCESS or some kind of error code. It's important to understand that SUCCESS doesn't imply that the command was synchronously executed. It really just means that the command was received and queued. Some devices can synchronously process a command, e.g. quickly writing to memory mapped I/O, but you'd never want to block in a gateway application to perform a downstream Modbus transaction. You'd pass the control of to another thread or queue the operation in some way for subsequent processing.","title":"CommandStatus"},{"location":"api/tls/","text":"Transport Layer Security (TLS) Opendnp3 provides support for TLS with mutual authentication using ASIO's C++ wrapper around openssl. Bulding the library with TLS support provides two additional channel types: TLSServer and TLSClient . DNP3Manager has provides methods for creating these channel types which take an additional configuration structure called TLSConfig . Each side of the TLS channel must provide 3 items: A certificate (either self-signed or root certificate) that will be used to authenticate the peer certificate. A local certificate, or certificate chain, to send to the peer. A private key corresponding to the public key in the local certificate used to authenticate. Refer to the documentation for TLSConfig for details. There are example certificates and private keys in the cpp\\tests\\asiotests\\certs directory. These certificates are examples only and used in component tests to ensure openssl can perform a sucessful handshake. Important All keys and certificates must be provided in the PEM format","title":"TLS Support"},{"location":"api/tls/#transport-layer-security-tls","text":"Opendnp3 provides support for TLS with mutual authentication using ASIO's C++ wrapper around openssl. Bulding the library with TLS support provides two additional channel types: TLSServer and TLSClient . DNP3Manager has provides methods for creating these channel types which take an additional configuration structure called TLSConfig . Each side of the TLS channel must provide 3 items: A certificate (either self-signed or root certificate) that will be used to authenticate the peer certificate. A local certificate, or certificate chain, to send to the peer. A private key corresponding to the public key in the local certificate used to authenticate. Refer to the documentation for TLSConfig for details. There are example certificates and private keys in the cpp\\tests\\asiotests\\certs directory. These certificates are examples only and used in component tests to ensure openssl can perform a sucessful handshake. Important All keys and certificates must be provided in the PEM format","title":"Transport Layer Security (TLS)"},{"location":"build/cmake/","text":"CMake Opendnp3 uses a build system generator called CMake . This means that the actual build files (e.g. a Makefile or Visual Studio .SLN) are generated from a artifact. This allows the opendnp3 project to maintain a single project file for all platforms, minimizing per-platform maintenance. CMake also integrates nicely with C++ IDEs like KDevelop or CLion . Optional Components By default, CMake will not build tests, demos, or TLS support. You can enable each optional component individually by specifying them on the command line: > cmake -D<option> = ON Option Name Comments DNP3_ALL build all optional components below DNP3_DEMO build the example programs DNP3_DOTNET build the .NET bindings (Windows only) DNP3_JAVA build the java bindings DNP3_TEST build the unit test suites DNP3_TLS build support for TLS channels (requires openssl >= 1.1.1) DNP3_DECODER build the decoder module DNP3_FUZZING build Google OSS-Fuzz integration For example, to build the demos including TLS support: > cmake -DDNP3_DEMO = ON -DDNP3_TLS = ON Locating ASIO Warning ASIO has made breaking changes in recent releases to tracking the emerging C++ networking API standardizations. Using the version of ASIO tagged in the git submodule ensures you always are on a compatible version. OpenDNP3 is currently using ASIO v1.16 . The included sub-folder of the ASIO distribution (the folder that contains 'asio.hpp') needs to be on your include path, but there are several ways you can do this. You can choose the option that makes the most sense your particular build environment. CMake will try the following things in order to locate your ASIO. 1) Look to see if you checked out ASIO as a git submodule when cloning opendnp3 > git clone --recursive https://github.com/automatak/dnp3.git 2) look to see if the variable ASIO_HOME was defined via the cmake command line. > cmake -DASIO_HOME = C:/libs/asio/include 3) Check if ASIO_HOME is defined as an environment variable. For instance, on Windows you might define your environment variable to look like this. ASIO_HOME = C:/libs/asio/include On Ubuntu Linux, you might add a line to ~/.bashrc as follows: export ASIO_HOME = ~/asio/include Tip If CMake can't find ASIO using one of the mechanisms above, it will just assume the headers are installed on the system. No checks are performed, so the build will fail is this isn't true Build Options Most of command-line options you can feed to CMake to generate your build environment are platform-independent. This documentation can't tell you everything that CMake can do. We only document some of the more common flags here for your convenience. All of the following examples assume an out-of-source build folder in a sibling directory to the opendnp3 distribution. Static vs Dynamic Linking You can switch between building static or dynamic linking using the STATICLIBS flag. Note that this flag is provided by the project and is not a CMake flag. On Windows, static libs are the default. On Linux, dynamic libs are the default. > cmake STATICLIBS=ON # build static libraries > cmake STATICLIBS=OFF # build dynamic libraries Debug vs Release You can configure release vs debug builds using the CMAKE_BUILD_TYPE flag. Note that on Windows, the generated SLN contains debug and release build targets already > cmake -DCMAKE_BUILD_TYPE = Debug > cmake -DCMAKE_BUILD_TYPE = Release Non-default generators By default, CMake will pick a generator to use if you don't tell it which one. You can see a list of all available generators using the help flag. > cmake --help You can then specify a specific generator, e.g. to do a full 64-bit build on Windows: > mkdir build64 > cmake .. -DDNP3_ALL = ON -G \"Visual Studio 14 2015 Win64\" Setting the install prefix If the default install location isn't where you want it to be, you can configure it using CMAKE_INSTALL_PREFIX . On Debian-based systems this should probably be: > cmake .. -DCMAKE_INSTALL_PREFIX = /usr/lib On windows, you might put your libraries and headers somewhere like: > cmake .. -DCMAKE_INSTALL_PREFIX = C: \\l ibs \\o pendnp3","title":"CMake"},{"location":"build/cmake/#cmake","text":"Opendnp3 uses a build system generator called CMake . This means that the actual build files (e.g. a Makefile or Visual Studio .SLN) are generated from a artifact. This allows the opendnp3 project to maintain a single project file for all platforms, minimizing per-platform maintenance. CMake also integrates nicely with C++ IDEs like KDevelop or CLion .","title":"CMake"},{"location":"build/cmake/#optional-components","text":"By default, CMake will not build tests, demos, or TLS support. You can enable each optional component individually by specifying them on the command line: > cmake -D<option> = ON Option Name Comments DNP3_ALL build all optional components below DNP3_DEMO build the example programs DNP3_DOTNET build the .NET bindings (Windows only) DNP3_JAVA build the java bindings DNP3_TEST build the unit test suites DNP3_TLS build support for TLS channels (requires openssl >= 1.1.1) DNP3_DECODER build the decoder module DNP3_FUZZING build Google OSS-Fuzz integration For example, to build the demos including TLS support: > cmake -DDNP3_DEMO = ON -DDNP3_TLS = ON","title":"Optional Components"},{"location":"build/cmake/#locating-asio","text":"Warning ASIO has made breaking changes in recent releases to tracking the emerging C++ networking API standardizations. Using the version of ASIO tagged in the git submodule ensures you always are on a compatible version. OpenDNP3 is currently using ASIO v1.16 . The included sub-folder of the ASIO distribution (the folder that contains 'asio.hpp') needs to be on your include path, but there are several ways you can do this. You can choose the option that makes the most sense your particular build environment. CMake will try the following things in order to locate your ASIO. 1) Look to see if you checked out ASIO as a git submodule when cloning opendnp3 > git clone --recursive https://github.com/automatak/dnp3.git 2) look to see if the variable ASIO_HOME was defined via the cmake command line. > cmake -DASIO_HOME = C:/libs/asio/include 3) Check if ASIO_HOME is defined as an environment variable. For instance, on Windows you might define your environment variable to look like this. ASIO_HOME = C:/libs/asio/include On Ubuntu Linux, you might add a line to ~/.bashrc as follows: export ASIO_HOME = ~/asio/include Tip If CMake can't find ASIO using one of the mechanisms above, it will just assume the headers are installed on the system. No checks are performed, so the build will fail is this isn't true","title":"Locating ASIO"},{"location":"build/cmake/#build-options","text":"Most of command-line options you can feed to CMake to generate your build environment are platform-independent. This documentation can't tell you everything that CMake can do. We only document some of the more common flags here for your convenience. All of the following examples assume an out-of-source build folder in a sibling directory to the opendnp3 distribution.","title":"Build Options"},{"location":"build/cmake/#static-vs-dynamic-linking","text":"You can switch between building static or dynamic linking using the STATICLIBS flag. Note that this flag is provided by the project and is not a CMake flag. On Windows, static libs are the default. On Linux, dynamic libs are the default. > cmake STATICLIBS=ON # build static libraries > cmake STATICLIBS=OFF # build dynamic libraries","title":"Static vs Dynamic Linking"},{"location":"build/cmake/#debug-vs-release","text":"You can configure release vs debug builds using the CMAKE_BUILD_TYPE flag. Note that on Windows, the generated SLN contains debug and release build targets already > cmake -DCMAKE_BUILD_TYPE = Debug > cmake -DCMAKE_BUILD_TYPE = Release","title":"Debug vs Release"},{"location":"build/cmake/#non-default-generators","text":"By default, CMake will pick a generator to use if you don't tell it which one. You can see a list of all available generators using the help flag. > cmake --help You can then specify a specific generator, e.g. to do a full 64-bit build on Windows: > mkdir build64 > cmake .. -DDNP3_ALL = ON -G \"Visual Studio 14 2015 Win64\"","title":"Non-default generators"},{"location":"build/cmake/#setting-the-install-prefix","text":"If the default install location isn't where you want it to be, you can configure it using CMAKE_INSTALL_PREFIX . On Debian-based systems this should probably be: > cmake .. -DCMAKE_INSTALL_PREFIX = /usr/lib On windows, you might put your libraries and headers somewhere like: > cmake .. -DCMAKE_INSTALL_PREFIX = C: \\l ibs \\o pendnp3","title":"Setting the install prefix"},{"location":"build/java/","text":"The Java bindings are built as two separate pieces: standard JAR file native shared library built from the C++ source Important Java 1.8 or greater is required because of features used in Java bindings Building the C++ bindings Use the '-DDNP3_JAVA=ON' option when configuring CMake. CMake will locate your JNI headers using the JAVA_HOME environment variable. The shared library must be installed in a system location or the path specified using the system.library.path JVM option. Building the JAR The pure Java part of the bindings is built and installed locally using Maven: > cd java > mvn install You can optionally suppress the integration tests during the build (e.g. if you don't have library installed): > mvn install -DskipTests You can now use it in your Maven based Java projects using <dependencies> ... <dependency> <groupId> com.automatak.dnp3 </groupId> <artifactId> opendnp3-bindings </artifactId> <version> ${opendnp3.version} </version> </dependency> ... </dependencies>","title":"Java"},{"location":"build/java/#building-the-c-bindings","text":"Use the '-DDNP3_JAVA=ON' option when configuring CMake. CMake will locate your JNI headers using the JAVA_HOME environment variable. The shared library must be installed in a system location or the path specified using the system.library.path JVM option.","title":"Building the C++ bindings"},{"location":"build/java/#building-the-jar","text":"The pure Java part of the bindings is built and installed locally using Maven: > cd java > mvn install You can optionally suppress the integration tests during the build (e.g. if you don't have library installed): > mvn install -DskipTests You can now use it in your Maven based Java projects using <dependencies> ... <dependency> <groupId> com.automatak.dnp3 </groupId> <artifactId> opendnp3-bindings </artifactId> <version> ${opendnp3.version} </version> </dependency> ... </dependencies>","title":"Building the JAR"},{"location":"build/linux/","text":"On linux, the easiest way to use CMake is just to let it create a makefile for you. You can then use this makefile in the same way you normally would: > mkdir build ; cd build > cmake .. <options> > make -j > sudo make install Cross-compiling CMake also supports cross-compiling to embedded-linux platforms. How to do this is outside the scope of this documentation, but is explained here . The preferred method is to create a toolchain file for each target platform.","title":"Linux"},{"location":"build/linux/#cross-compiling","text":"CMake also supports cross-compiling to embedded-linux platforms. How to do this is outside the scope of this documentation, but is explained here . The preferred method is to create a toolchain file for each target platform.","title":"Cross-compiling"},{"location":"build/requirements/","text":"Platforms OpenDNP3 is a cross-platform C++ library. It is tested on Linux and Windows. C++14 OpenDNP3 uses the following C++11/14 features: std::unique_ptr & std::shared_ptr (including std::make_unique , part of C++14) - smart pointers are used for automatic memory management std::thread - platform-independent threading used to manage the thread pool std::chrono - platform-independent time operations including steady-clock used to manage timers variadic templates - used to simplify parsing routines. ASIO ASIO is a header-only library that provides asynchronous I/O (ASIO). OpenDNP3 uses ASIO for several things. Cross-platform sockets Cross-platform serial ports A multi-core event loop Abstract timers on top of std::chrono Compilers The following compilers are known to work, and are tested frequently. MSVC++ - Visual Studio >= 2019 g++ >= 4.9.x clang >= 3.5","title":"Requirements"},{"location":"build/requirements/#platforms","text":"OpenDNP3 is a cross-platform C++ library. It is tested on Linux and Windows.","title":"Platforms"},{"location":"build/requirements/#c14","text":"OpenDNP3 uses the following C++11/14 features: std::unique_ptr & std::shared_ptr (including std::make_unique , part of C++14) - smart pointers are used for automatic memory management std::thread - platform-independent threading used to manage the thread pool std::chrono - platform-independent time operations including steady-clock used to manage timers variadic templates - used to simplify parsing routines.","title":"C++14"},{"location":"build/requirements/#asio","text":"ASIO is a header-only library that provides asynchronous I/O (ASIO). OpenDNP3 uses ASIO for several things. Cross-platform sockets Cross-platform serial ports A multi-core event loop Abstract timers on top of std::chrono","title":"ASIO"},{"location":"build/requirements/#compilers","text":"The following compilers are known to work, and are tested frequently. MSVC++ - Visual Studio >= 2019 g++ >= 4.9.x clang >= 3.5","title":"Compilers"},{"location":"build/source/","text":"The core C++ library lives in cpp/lib/ . Public headers are in cpp/lib/include/opendnp3 . The library has no public external dependencies. ASIO is completely hidden from the public API. When building an external application on Linux without TLS support, you need only need to link against opendnp3: -lopendnp3 CLR Bindings The .NET bindings live in the dotnet folder. CMake can optionally generate the projects for them as part of the SLN file during build configuration. # CLR bindings built using CMake /dotnet /CLRAdapter // a C++/CLI project that adapts the underlying C++ libraries to C# /CLRInterface // Pure CLR interfaces and classes that comprise the API /examples // C# example applications Java Bindings The java bindings live in the java folder. CMake can optionally generate the projects for them as part of the SLN or makefile during build configuration. # Java bindings built using CMake (native) and Maven (pom.xml) /java /bindings // Java w/ native stubs /codegen // Code generator written in Scala that generates C++ JNI boilerplate /cpp // C++ compiled to libopendnp3java.dll/so /example // Java example programs that depend on api/bindings Jars","title":"Source Tree"},{"location":"build/source/#clr-bindings","text":"The .NET bindings live in the dotnet folder. CMake can optionally generate the projects for them as part of the SLN file during build configuration. # CLR bindings built using CMake /dotnet /CLRAdapter // a C++/CLI project that adapts the underlying C++ libraries to C# /CLRInterface // Pure CLR interfaces and classes that comprise the API /examples // C# example applications","title":"CLR Bindings"},{"location":"build/source/#java-bindings","text":"The java bindings live in the java folder. CMake can optionally generate the projects for them as part of the SLN or makefile during build configuration. # Java bindings built using CMake (native) and Maven (pom.xml) /java /bindings // Java w/ native stubs /codegen // Code generator written in Scala that generates C++ JNI boilerplate /cpp // C++ compiled to libopendnp3java.dll/so /example // Java example programs that depend on api/bindings Jars","title":"Java Bindings"},{"location":"build/windows/","text":"On Windows, CMake is used to generate a Visual Studio Solution (SLN) and associated project files. > mkdir build ; cd build > cmake .. <options> Once you've generated your SLN, you can just open it and use Visual Studio to build the project for you just like any other project. Command Line Alternatively, you can just invoke msbuild.exe on the generated solution and build from the command line. > msbuild opendnp3.sln or > cmake --build . Installing CMake creates a special project called \"install\" that you can run inside Visual Studio to install the headers and libraries to the directory specified by CMAKE_INSTALL_PREFIX . TLS Support If you need to build the stack w/ TLS support (or you're using the .NET bindings), then you need to install OpenSSL on Windows. Use the full development pacakge installers from ShiningLight . Cmake is able to find the openssl libraries and headers in the default install locations used by the installer. .NET Bindings By far, the easiest way to use the .NET bindings is just to install the Nuget package we publish: PM> Install-Package opendnp3 or to allow pre-release versions: PM> Install-Package opendnp3 -Pre Building If you need to build them from scratch, you can enable it when configuring CMake, e.g.: > cmake .. -DDNP3_DOTNET=ON","title":"Windows"},{"location":"build/windows/#command-line","text":"Alternatively, you can just invoke msbuild.exe on the generated solution and build from the command line. > msbuild opendnp3.sln or > cmake --build .","title":"Command Line"},{"location":"build/windows/#installing","text":"CMake creates a special project called \"install\" that you can run inside Visual Studio to install the headers and libraries to the directory specified by CMAKE_INSTALL_PREFIX .","title":"Installing"},{"location":"build/windows/#tls-support","text":"If you need to build the stack w/ TLS support (or you're using the .NET bindings), then you need to install OpenSSL on Windows. Use the full development pacakge installers from ShiningLight . Cmake is able to find the openssl libraries and headers in the default install locations used by the installer.","title":"TLS Support"},{"location":"build/windows/#net-bindings","text":"By far, the easiest way to use the .NET bindings is just to install the Nuget package we publish: PM> Install-Package opendnp3 or to allow pre-release versions: PM> Install-Package opendnp3 -Pre","title":".NET Bindings"},{"location":"build/windows/#building","text":"If you need to build them from scratch, you can enable it when configuring CMake, e.g.: > cmake .. -DDNP3_DOTNET=ON","title":"Building"},{"location":"faq/faq/","text":"Frequently Asked Questions Unable to find asio.hpp You need to tell CMake where the ASIO headers are located. Please review the CMake instructions . Unable to load DNP3CLRAdapter or one of its dependencies .NET does not provide useful error messages when an assembly can't find a native dependency. The .NET bindings depend on the Visual C++ Runtime library for the version of Visual Studio you used to build them. These packages can be found from Microsoft by searching for \"Visual Studio C++ Runtime\" in your favorite search engine. You might also see this error because CLRAdapter can't find openssl (libeay32.dll / libssl32.dll) if your bindings didn't have these linked statically. The solution is to make sure openssl is installed in the correct system location. My master and outstation don't communicate The most common mistake when configuring a master to talk to an outstation is neglecting to set the correct addresses. DNP3 was originally designed to communicate on a shared serial bus, so components ignore messages sent to addresses other than their own . Outstations expect to receive messages from a particular master, and will only respond to that master if both the source and destination link-layer addresses are set correctly. Master or Outstation doesn't detect an ethernet cable being unplugged There is no way through the standard socket API to detect this, other than trying to write data to the socket. This means that if master or outstation sessions are quiescent (meaning that they don't write data periodically), you should be using the link-layer keep-alive feature to ensure that dead/hung connections are appropriately detected.","title":"FAQ"},{"location":"faq/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/faq/#unable-to-find-asiohpp","text":"You need to tell CMake where the ASIO headers are located. Please review the CMake instructions .","title":"Unable to find asio.hpp"},{"location":"faq/faq/#unable-to-load-dnp3clradapter-or-one-of-its-dependencies","text":".NET does not provide useful error messages when an assembly can't find a native dependency. The .NET bindings depend on the Visual C++ Runtime library for the version of Visual Studio you used to build them. These packages can be found from Microsoft by searching for \"Visual Studio C++ Runtime\" in your favorite search engine. You might also see this error because CLRAdapter can't find openssl (libeay32.dll / libssl32.dll) if your bindings didn't have these linked statically. The solution is to make sure openssl is installed in the correct system location.","title":"Unable to load DNP3CLRAdapter or one of its dependencies"},{"location":"faq/faq/#my-master-and-outstation-dont-communicate","text":"The most common mistake when configuring a master to talk to an outstation is neglecting to set the correct addresses. DNP3 was originally designed to communicate on a shared serial bus, so components ignore messages sent to addresses other than their own . Outstations expect to receive messages from a particular master, and will only respond to that master if both the source and destination link-layer addresses are set correctly.","title":"My master and outstation don't communicate"},{"location":"faq/faq/#master-or-outstation-doesnt-detect-an-ethernet-cable-being-unplugged","text":"There is no way through the standard socket API to detect this, other than trying to write data to the socket. This means that if master or outstation sessions are quiescent (meaning that they don't write data periodically), you should be using the link-layer keep-alive feature to ensure that dead/hung connections are appropriately detected.","title":"Master or Outstation doesn't detect an ethernet cable being unplugged"},{"location":"features/3.0/","text":"Easier to build OpenDNP3 was refactored to create a single library that is easy to build and to use. Simply link with opendnp3 and you are good to go. The CMake was completely refactored to modern practices and no longer affects global flags. Therefore, it is possible to include OpenDNP3 as a submodule in your CMake project and simply add_subdirectory to include it to your compilation process. Private dependencies needed to build the library are now automatically fetched by CMake. No more submodule to sync or dependencies out of sync. The only dependency that still needs to be installed on the build system is OpenSSL if TLS support is required. Intuitive API The outstation database was refactored to simplify its usage. The points are now described using a map instead of an array of indices. It is no longer required to have them in a particular order since the map will automatically order them. It is also no longer required to specify if points are in order or not. To ease the common usage of updating points when receiving a command, an IUpdateBuilder is now provided in every callback of ICommandHandler . Also, begin and end callbacks were added to help determine which commands are grouped together in a single APDU. On the master side, the ISOEHandler was updated to include begin_fragment and end_fragment callbacks. Each of these callbacks receive a ResponseInfo to help determine if it's a multi-fragment response or an unsolicited response. To help distinguish which request generated which response, it is now possible to provide a distinct SOEHandler on each request. To help users reading configuration parameters from files, all the public enumerations used by the library exposes a to_string and a from_string method. It also exposes a to_type and from_type to convert to the underlying integer value. Control Relay Output Block was refactored to expose every field individually instead of providing a gigantic enum with all the possible (and sometimes impossible) values. Full conformance OpenDNP3 is now fully compliant with DNP3 Subset Level 2. It includes the following features that were previously missing: Immediate Freeze (0x07), Immediate Freeze No Ack (0x08), Freeze-and-Clear (0x09) and Freeze-and-Clear No Ack (0x10) support Broadcast support UDP support Unsolicited retry count Timestamp quality (for proper CTO variation) Conformance testing is automatically performed on every commit and detailed reports are publicly available . Better testing An extensive continuous integration setup was setup to make sure that the library is always in great shape and that no regression are introduced. You can see the integration pipeline being executed here . Also, each commit will have a \u2714 that you can click to see the results. The CI pipeline also produces ready-to-use packages for each platform. It also produces NuGet packages of the C# bindings and Maven packages of the Java bindings that can be used as is. Finally, conformance results including packet captures are also made available. More extensive integration testing were written for the 3.0 release to ensure the library always behave as expected. Some of these integration tests were written using the Java bindings and are also executed by the CI pipeline. Full conformance testing using the latest test procedure developed by the DNP Users Group are executed on every commit. For information about the product used for automatic conformance testing and you can use it to assess the conformity of your devices, contact Automatak . Other changes Sending confirmed data-link frames is not supported anymore. This feature has caused many issues and is not well specified in the standard itself. It is not required for conformance and should never be used in the real world. Please note that the library still supports receiving confirmed data-link frames and will confirm them, maintaining full interoperability with all conforming equipment. The ASIO dependency was updated to v1.16 .","title":"Changes to 3.x release"},{"location":"features/3.0/#easier-to-build","text":"OpenDNP3 was refactored to create a single library that is easy to build and to use. Simply link with opendnp3 and you are good to go. The CMake was completely refactored to modern practices and no longer affects global flags. Therefore, it is possible to include OpenDNP3 as a submodule in your CMake project and simply add_subdirectory to include it to your compilation process. Private dependencies needed to build the library are now automatically fetched by CMake. No more submodule to sync or dependencies out of sync. The only dependency that still needs to be installed on the build system is OpenSSL if TLS support is required.","title":"Easier to build"},{"location":"features/3.0/#intuitive-api","text":"The outstation database was refactored to simplify its usage. The points are now described using a map instead of an array of indices. It is no longer required to have them in a particular order since the map will automatically order them. It is also no longer required to specify if points are in order or not. To ease the common usage of updating points when receiving a command, an IUpdateBuilder is now provided in every callback of ICommandHandler . Also, begin and end callbacks were added to help determine which commands are grouped together in a single APDU. On the master side, the ISOEHandler was updated to include begin_fragment and end_fragment callbacks. Each of these callbacks receive a ResponseInfo to help determine if it's a multi-fragment response or an unsolicited response. To help distinguish which request generated which response, it is now possible to provide a distinct SOEHandler on each request. To help users reading configuration parameters from files, all the public enumerations used by the library exposes a to_string and a from_string method. It also exposes a to_type and from_type to convert to the underlying integer value. Control Relay Output Block was refactored to expose every field individually instead of providing a gigantic enum with all the possible (and sometimes impossible) values.","title":"Intuitive API"},{"location":"features/3.0/#full-conformance","text":"OpenDNP3 is now fully compliant with DNP3 Subset Level 2. It includes the following features that were previously missing: Immediate Freeze (0x07), Immediate Freeze No Ack (0x08), Freeze-and-Clear (0x09) and Freeze-and-Clear No Ack (0x10) support Broadcast support UDP support Unsolicited retry count Timestamp quality (for proper CTO variation) Conformance testing is automatically performed on every commit and detailed reports are publicly available .","title":"Full conformance"},{"location":"features/3.0/#better-testing","text":"An extensive continuous integration setup was setup to make sure that the library is always in great shape and that no regression are introduced. You can see the integration pipeline being executed here . Also, each commit will have a \u2714 that you can click to see the results. The CI pipeline also produces ready-to-use packages for each platform. It also produces NuGet packages of the C# bindings and Maven packages of the Java bindings that can be used as is. Finally, conformance results including packet captures are also made available. More extensive integration testing were written for the 3.0 release to ensure the library always behave as expected. Some of these integration tests were written using the Java bindings and are also executed by the CI pipeline. Full conformance testing using the latest test procedure developed by the DNP Users Group are executed on every commit. For information about the product used for automatic conformance testing and you can use it to assess the conformity of your devices, contact Automatak .","title":"Better testing"},{"location":"features/3.0/#other-changes","text":"Sending confirmed data-link frames is not supported anymore. This feature has caused many issues and is not well specified in the standard itself. It is not required for conformance and should never be used in the real world. Please note that the library still supports receiving confirmed data-link frames and will confirm them, maintaining full interoperability with all conforming equipment. The ASIO dependency was updated to v1.16 .","title":"Other changes"},{"location":"features/features/","text":"Performance OpenDNP3 is engineered to perform exceptionally well for large systems with hundreds or even thousands of concurrent sessions: The protocol stack uses non-blocking I/O and runs on a thread-pool. This makes it extremely memory and CPU efficient at scale. Zero-copy / zero-allocation parsing. When parsing an application layer message, the parser doesn't create a full object model representation of the message. This makes the processing of requests extremely fast and efficient. Robustness & Security The principal developers who work on opendnp3 have lead the charge in the industry in terms of security testing DNP3 . You won't find a more reliable implementation of the protocol anywhere. Our commitment to a high-quality project is evident in what we do. An exhaustive unit test suite in excess of 80% coverage (excluding the generated files) Full continuous integration on Windows (64-bit and 32-bit) and Linux (using GCC and Clang) Fuzzing using the Aegis fuzzer and Google's OSS Fuzz Static analysis using tools like LGTM , Coverity and cppcheck We provide integrated TLS support that makes opendnp3 an ideal solution for integrating with real-time markets programs like PJM Jetstream . Compliance IEEE-1815 defines 4 subset levels (1-4) that consist of the objects and function codes that must be supported by the master and outstation. Conformance tests only exist for subset levels 1 & 2. The OpenDNP3 stack is automatically tested against the latest DNP3 IED Certification Procedure (Subset Level 2) on every commit . The detailed report with the associated packet captures are available publicly. For the latest results, go here , click on the latest commit, and download conformance-results-{GIT_SHA} file. The device profile representing the virtual device used in these tests can be found here . For information about the product used for automatic conformance testing and you can use it to assess the conformity of your devices, contact Automatak . You can also configure the library to act as a Subset Level 1 device. The stack currently meets all the Subset Level 2 requirements. Subset Levels 1-4 Level Support Missing Features 1 FULL 2 FULL 3 PARTIAL read g50v1 (Absolute Time and Date), read g80v1 (Internal Indications) 4 PARTIAL Self-address, analog dead-bands (group 34), device attributes (group 0), command events (groups 13 & 43) Subset Level 4+ Feature Support Comment Octet strings (group 110/11) FULL Empty strings not allowed Virtual Terminal NONE Secure Authentication NONE Use TLS. See this paper for more details File Transfer NONE Datasets NONE If your integration requires some functionality not currently implemented, consider sponsoring the additions. Portability OpenDNP3 supports Windows and Linux operating systems. The continuous integration pipeline validates that it compiles on both platforms with various compilers. Connections can be established using TCP/IP, a serial link, or a UDP connection. Note that we do not recommend using UDP for DNP3 connections, as it places additional requirements on how DNP3 is used, e.g. requests and responses must fit in a single datagram. To ease usage in existing codebases, C# and Java bindings are also available. They expose a complete and easy-to-use interface to interact with the library.","title":"Features"},{"location":"features/features/#performance","text":"OpenDNP3 is engineered to perform exceptionally well for large systems with hundreds or even thousands of concurrent sessions: The protocol stack uses non-blocking I/O and runs on a thread-pool. This makes it extremely memory and CPU efficient at scale. Zero-copy / zero-allocation parsing. When parsing an application layer message, the parser doesn't create a full object model representation of the message. This makes the processing of requests extremely fast and efficient.","title":"Performance"},{"location":"features/features/#robustness-security","text":"The principal developers who work on opendnp3 have lead the charge in the industry in terms of security testing DNP3 . You won't find a more reliable implementation of the protocol anywhere. Our commitment to a high-quality project is evident in what we do. An exhaustive unit test suite in excess of 80% coverage (excluding the generated files) Full continuous integration on Windows (64-bit and 32-bit) and Linux (using GCC and Clang) Fuzzing using the Aegis fuzzer and Google's OSS Fuzz Static analysis using tools like LGTM , Coverity and cppcheck We provide integrated TLS support that makes opendnp3 an ideal solution for integrating with real-time markets programs like PJM Jetstream .","title":"Robustness &amp; Security"},{"location":"features/features/#compliance","text":"IEEE-1815 defines 4 subset levels (1-4) that consist of the objects and function codes that must be supported by the master and outstation. Conformance tests only exist for subset levels 1 & 2. The OpenDNP3 stack is automatically tested against the latest DNP3 IED Certification Procedure (Subset Level 2) on every commit . The detailed report with the associated packet captures are available publicly. For the latest results, go here , click on the latest commit, and download conformance-results-{GIT_SHA} file. The device profile representing the virtual device used in these tests can be found here . For information about the product used for automatic conformance testing and you can use it to assess the conformity of your devices, contact Automatak . You can also configure the library to act as a Subset Level 1 device. The stack currently meets all the Subset Level 2 requirements.","title":"Compliance"},{"location":"features/features/#subset-levels-1-4","text":"Level Support Missing Features 1 FULL 2 FULL 3 PARTIAL read g50v1 (Absolute Time and Date), read g80v1 (Internal Indications) 4 PARTIAL Self-address, analog dead-bands (group 34), device attributes (group 0), command events (groups 13 & 43)","title":"Subset Levels 1-4"},{"location":"features/features/#subset-level-4","text":"Feature Support Comment Octet strings (group 110/11) FULL Empty strings not allowed Virtual Terminal NONE Secure Authentication NONE Use TLS. See this paper for more details File Transfer NONE Datasets NONE If your integration requires some functionality not currently implemented, consider sponsoring the additions.","title":"Subset Level 4+"},{"location":"features/features/#portability","text":"OpenDNP3 supports Windows and Linux operating systems. The continuous integration pipeline validates that it compiles on both platforms with various compilers. Connections can be established using TCP/IP, a serial link, or a UDP connection. Note that we do not recommend using UDP for DNP3 connections, as it places additional requirements on how DNP3 is used, e.g. requests and responses must fit in a single datagram. To ease usage in existing codebases, C# and Java bindings are also available. They expose a complete and easy-to-use interface to interact with the library.","title":"Portability"}]}