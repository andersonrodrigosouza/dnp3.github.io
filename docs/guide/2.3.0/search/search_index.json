{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to opendnp3, a portable, rigorously-tested, Apache-licensed implementation of the DNP3 protocol (aka IEEE-1815). Warning DNP3 is a complex protocol with many subtle rules. This guide and the opendnp3 project cannot cover everything about the protocol. To successfully use opendnp3 or develop a product based on it, you will almost certainly need a copy of the specification. We recommend that your organization joins DNP.org to obtain a copy. Important Links Project Homepage - The official project homepage. Github Repository - You'll find the tagged releases here as well as the development branches. Google Group - Post questions and receive updates. Free support is provided as time permits. DNP Users Group - The official DNP3 user group. Join and get a copy of the standard. Getting Support If you need dedicated commercial support, custom integration services, or compliance/security testing contact Automatak . If the library does not contain a feature that you need for your device or application, please consider sponsoring the addition.","title":"Introduction"},{"location":"#important-links","text":"Project Homepage - The official project homepage. Github Repository - You'll find the tagged releases here as well as the development branches. Google Group - Post questions and receive updates. Free support is provided as time permits. DNP Users Group - The official DNP3 user group. Join and get a copy of the standard.","title":"Important Links"},{"location":"#getting-support","text":"If you need dedicated commercial support, custom integration services, or compliance/security testing contact Automatak . If the library does not contain a feature that you need for your device or application, please consider sponsoring the addition.","title":"Getting Support"},{"location":"api/architecture/","text":"All opendnp3 programs begin by creating a DNP3Manager . Creating this object allocates a thread pool used to process events and callbacks to user code. // Create a root DNP3 manager with a single thread that logs to the console DNP3Manager manager ( 1 , ConsoleLogger :: Create ()); If you're familiar with using ASIO in other contexts, than it should be no surprise that the DNP3Manager owns an asio::io_context . It also has a thread pool for calling asio::io_context::run() , however, this is an internal detail that most opendnp3 programmers do not need to know to use the stack. How many threads you allocate to your thread pool can be a subtle matter. On simple systems like a small outstation that only talks to a single master, one thread is sufficient. For masters that may talk to hundreds or thousands of outstations, you'll want to scale your thread-pool to the number of logical processors on your machine. // Create a root DNP3 manager as many threads as logical processors DNP3Manager manager ( std :: hardware_concurrency (), ConsoleLogger :: Create ()); Warning You should avoid blocking the stack during callbacks made to user code, as there are a limited number of threads in the thread pool. This advice is especially critical for large systems where the number of communication channels greatly outnumbers the number of threads in the pool. If all of your threads are blocked then other channels can't do useful work like sending control requests to the field. Blocking operations should be done in separate threads. If you must design your system to do some blocking operations without handling other threads, you can mitigate this problem by scaling the number of threads in the pool as a multiple of the number of cores. // Create a root DNP3 manager with twice as many threads as logical processors DNP3Manager manager ( 2 * std :: hardware_concurrency (), ConsoleLogger :: Create ()); Properly configuring your thread pool ensures optimal performance. Channels & Sessions Communication channels are created from the root DNP3Manager class. // Create a TCP client channel to which we can bind masters or outstations auto channel = manager . AddTCPClient (... arguments ...); There is a unique method for adding each supported channel type, TCPClient , TCPServer , TLSClient , TLSServer , or Serial . You should refer to code documentation for a description of the parameters. With your channels created you can now bind master or outstations sessions to your them. Binding multiple master or outstations sessions to a single channel is a multi-drop configuration. // Create a master bound to a particular channel auto master = channel -> AddMaster (... arguments ...); // Create an outstation bound to particular channel auto outstation = channel -> AddOutstation (... arguments ...); Architecture Each channel and the sessions bound to it, are a single-threaded state-machine. During execution, ASIO guarantees that each channel is only processing one event at a time from a single thread. This means that there is no explicit thread synchronization required anywhere in the stack. When user code wants to communicate with a stack, e.g. load measurement data into an outstation or request that a command be initiated on a master, it gets \"posted\" to the correct channel's executor. This ensures that each channel and all the sessions bound to it are only ever touched by a single thread at a time. User code, however, may need to worry about multi-threading. If you hand the same callback interface to multiple sessions, you will potentially receive callbacks from multiple threads simultaneously on the same interface.","title":"Architecture"},{"location":"api/architecture/#channels-sessions","text":"Communication channels are created from the root DNP3Manager class. // Create a TCP client channel to which we can bind masters or outstations auto channel = manager . AddTCPClient (... arguments ...); There is a unique method for adding each supported channel type, TCPClient , TCPServer , TLSClient , TLSServer , or Serial . You should refer to code documentation for a description of the parameters. With your channels created you can now bind master or outstations sessions to your them. Binding multiple master or outstations sessions to a single channel is a multi-drop configuration. // Create a master bound to a particular channel auto master = channel -> AddMaster (... arguments ...); // Create an outstation bound to particular channel auto outstation = channel -> AddOutstation (... arguments ...);","title":"Channels &amp; Sessions"},{"location":"api/architecture/#architecture","text":"Each channel and the sessions bound to it, are a single-threaded state-machine. During execution, ASIO guarantees that each channel is only processing one event at a time from a single thread. This means that there is no explicit thread synchronization required anywhere in the stack. When user code wants to communicate with a stack, e.g. load measurement data into an outstation or request that a command be initiated on a master, it gets \"posted\" to the correct channel's executor. This ensures that each channel and all the sessions bound to it are only ever touched by a single thread at a time. User code, however, may need to worry about multi-threading. If you hand the same callback interface to multiple sessions, you will potentially receive callbacks from multiple threads simultaneously on the same interface.","title":"Architecture"},{"location":"api/channels/","text":"The library uses abstract communication channels to send and receive bytes \"over the wire\". Opendnp3 supports TCP client/server, TLS client/server, and serial communications. UDP may be added in the future. The manager that you created previously is now ready to have some channels bound to it. Adding a channel to the manager does not make it attempt to open immediately. If it's a TCP socket or serial port it won't try to open until you bind at least one outstation or master session and enable it. Here's an example of how you go about adding a TCP client. Assume we have a DNP3Manager called 'manager': auto channel = manager . AddTCPClient ( \"tcpclient\" , // alias used in log messages levels :: NORMAL , // bitfield used to filter what gets logged ChannelRetry :: Default (), // determines how connections will be retried \"127.0.0.1\" , // host name (DNS resolved) or IP address of remote endpoint \"0.0.0.0\" , // adapter on which to attempt the connection (any adapter) 20000 , // port remote endpoint is listening on nullptr // optional listener interface for monitoring the channel ); The API for creating TCPServer channels or Serial channels is very similar. Just refer to the code documentation. Exponential backoff The ChannelRetry configuration specifies two timing parameters for the minimum and maximum connection retry times using an exponential back-off strategy. If you don't want exponential back-off, just set the minimum and maximum to the same value for a consistent delay. Exponential back-off really only makes sense for initiating TCP connections. For instance if you set the minimum to TimeDuration::Seconds(3) and the maximum to TimeDuration::Seconds(40) a series of failed connections would have the following time gaps between attempts. 3, 6, 12, 24, 40, 40, ..... Monitoring channels Most of the time your communication channel is open and passing dnp3 traffic back and forth. Sometimes, however, things can go wrong with your network or you have mis-configured your connection. when creating your channel, you can pass in a shared_ptr<IChannelListener> to monitor the state of channel. This interface provides a method returning an enumeration of the states of the channel: enum class ChannelState : uint8_t { /// offline and idle CLOSED = 0 , /// trying to open OPENING = 1 , /// open OPEN = 2 , /// stopped and will never do anything again SHUTDOWN = 3 }; Cleaning up Channels and all the sessions bound to them are automatically cleaned up when the DNP3Manager goes out of scope (or is deleted if allocated dynamically). You can manually remove a channel without having to stop every master or outstation bound to it by calling IChannel::Shutdown() . // permanently shutdown the channel channel -> Shutdown (); Calls to Shutdown() are idempotent. The resources for the underlying channel will be freed when you drop the reference to the shared_ptr<IChannel> .","title":"Channels"},{"location":"api/channels/#exponential-backoff","text":"The ChannelRetry configuration specifies two timing parameters for the minimum and maximum connection retry times using an exponential back-off strategy. If you don't want exponential back-off, just set the minimum and maximum to the same value for a consistent delay. Exponential back-off really only makes sense for initiating TCP connections. For instance if you set the minimum to TimeDuration::Seconds(3) and the maximum to TimeDuration::Seconds(40) a series of failed connections would have the following time gaps between attempts. 3, 6, 12, 24, 40, 40, .....","title":"Exponential backoff"},{"location":"api/channels/#monitoring-channels","text":"Most of the time your communication channel is open and passing dnp3 traffic back and forth. Sometimes, however, things can go wrong with your network or you have mis-configured your connection. when creating your channel, you can pass in a shared_ptr<IChannelListener> to monitor the state of channel. This interface provides a method returning an enumeration of the states of the channel: enum class ChannelState : uint8_t { /// offline and idle CLOSED = 0 , /// trying to open OPENING = 1 , /// open OPEN = 2 , /// stopped and will never do anything again SHUTDOWN = 3 };","title":"Monitoring channels"},{"location":"api/channels/#cleaning-up","text":"Channels and all the sessions bound to them are automatically cleaned up when the DNP3Manager goes out of scope (or is deleted if allocated dynamically). You can manually remove a channel without having to stop every master or outstation bound to it by calling IChannel::Shutdown() . // permanently shutdown the channel channel -> Shutdown (); Calls to Shutdown() are idempotent. The resources for the underlying channel will be freed when you drop the reference to the shared_ptr<IChannel> .","title":"Cleaning up"},{"location":"api/linklayer/","text":"The DNP3 link-layer is the lowest level of the DNP3 stack, and provides a number of services for DNP3 communications: Addressing - Each DNP3 frame contains both a 16-bit source and destination address field. Keep-alive - The ability to periodically send \"keep-alive\" requests ( REQUEST_LINK_STATUS ) Error-checking - Interleaved CRC values that can separately detect data corruption in the header and payload. Configuration Both master and outstation sessions require link-layer configuration. The MasterStackConfig and OutstationStackConfig configuration structures each contain a LinkConfig structure. This gives you access to the link-layer parameters when creating a master or outstation session. MasterStackConfig stackConfig ; // could also be OutstationStackConfig for an outstation // configure master specific parameters ...... // set link-layer parameters stackConfig . link . LocalAddr = 1 ; // the address of the master stackConfig . link . RemoteAddr = 10 ; // the address of the remote outstation Important Not having the link-layer Local/Remote addresses configured correctly is the most frequent source of communication problems. Opendnp3 example applications automatically talk to each other using a master address of 1 and an outstation address of 1024. There is no standard default address. Keep-alives The link-layer will send a keep-alive request whenever it hasn't received a message from the other side of the link within the LinkConfig.KeepAliveTimeout parameter. This configurable parameter defaults to 1 minute. It is generally only needed for quiescent TCP operations, and can be disabled for other types of configurations. It is an indispensable parameter for polled outstations that act as TCP servers. Writing to a socket is the only way to detect dead/half-open sockets. ILinkListener The IMasterApplication and IOutstationApplication interfaces inherit from ILinkListener . You can monitor important events at the link-layer by overriding the default methods on this interface. class ILinkListener { public : /// Called when a the reset/unreset status of the link layer changes virtual void OnStateChange ( LinkStatus value ) {} /// Called when the keep alive timer elapses. This doesn't denote a keep-alive failure, it's just a notification virtual void OnKeepAliveInitiated () {} /// Called when a keep alive message (request link status) receives no response virtual void OnKeepAliveFailure () {} /// Called when a keep alive message receives a valid response virtual void OnKeepAliveSuccess () {} }; The DNP3 specification details specific actions the master or outstation should take (like closing a TCP session and reconnecting) when keep-alive failures occur. Opendnp3 does not automatically perform these actions. User-code is expected to monitor this callback interface and take appropriate actions based on the type of communication channel in use.","title":"Link-Layer"},{"location":"api/linklayer/#configuration","text":"Both master and outstation sessions require link-layer configuration. The MasterStackConfig and OutstationStackConfig configuration structures each contain a LinkConfig structure. This gives you access to the link-layer parameters when creating a master or outstation session. MasterStackConfig stackConfig ; // could also be OutstationStackConfig for an outstation // configure master specific parameters ...... // set link-layer parameters stackConfig . link . LocalAddr = 1 ; // the address of the master stackConfig . link . RemoteAddr = 10 ; // the address of the remote outstation Important Not having the link-layer Local/Remote addresses configured correctly is the most frequent source of communication problems. Opendnp3 example applications automatically talk to each other using a master address of 1 and an outstation address of 1024. There is no standard default address.","title":"Configuration"},{"location":"api/linklayer/#keep-alives","text":"The link-layer will send a keep-alive request whenever it hasn't received a message from the other side of the link within the LinkConfig.KeepAliveTimeout parameter. This configurable parameter defaults to 1 minute. It is generally only needed for quiescent TCP operations, and can be disabled for other types of configurations. It is an indispensable parameter for polled outstations that act as TCP servers. Writing to a socket is the only way to detect dead/half-open sockets.","title":"Keep-alives"},{"location":"api/linklayer/#ilinklistener","text":"The IMasterApplication and IOutstationApplication interfaces inherit from ILinkListener . You can monitor important events at the link-layer by overriding the default methods on this interface. class ILinkListener { public : /// Called when a the reset/unreset status of the link layer changes virtual void OnStateChange ( LinkStatus value ) {} /// Called when the keep alive timer elapses. This doesn't denote a keep-alive failure, it's just a notification virtual void OnKeepAliveInitiated () {} /// Called when a keep alive message (request link status) receives no response virtual void OnKeepAliveFailure () {} /// Called when a keep alive message receives a valid response virtual void OnKeepAliveSuccess () {} }; The DNP3 specification details specific actions the master or outstation should take (like closing a TCP session and reconnecting) when keep-alive failures occur. Opendnp3 does not automatically perform these actions. User-code is expected to monitor this callback interface and take appropriate actions based on the type of communication channel in use.","title":"ILinkListener"},{"location":"api/logging/","text":"Listening You can bind to the opendnp3 log stream by calling passing a shared_ptr<ILogHandler> into the DNP3Manager constructor. This interface just has a single method: class ILogHandler { public : virtual void Log ( const LogEntry & entry ) = 0 ; }; If you need to send log messages to more than one location, create your own proxy ILogHandler . Keep in mind that this is a callback from the thread-pool and will block that thread from executing. A good strategy for a file-logger in a big system would be to send a message to a worker thread to write the message to disk. Individual loggers Each channel and stack instance (master or outstation) has its own logger whose log level can be individually configured and adjusted at run-time. This allows you to increase the log level of a particular channel or stack, without receiving full protocol analysis for everything and grinding the system to a halt. You specify the initial log level for each channel when it is created and this is inherited by stacks on that channel. You can adjust it during execute by calling IChannel::SetLogFilters , IMaster::SetLogFilters , or IOutstation::SetLogFilters . Log levels Opendnp3 defines a number of typical log levels like DEBUG, INFO, WARN, ERR. In addition it defines a number of log levels specific to the protocol dissection and analysis. Turning on all the various DNP3 analysis levels allows you to create useful communication traces like the following. ms ( 1440709781929 ) <-TL-- outstation - FIR: 1 FIN: 1 SEQ: 0 LEN: 11 ms ( 1440709781932 ) <-AL-- outstation - C0 15 3C 02 06 3C 03 06 3C 04 06 ms ( 1440709781934 ) <-AL-- outstation - FIR: 1 FIN: 1 CON: 0 UNS: 0 SEQ: 0 FUNC: DISABLE_UNSOLICITED ms ( 1440709781939 ) <-AL-- outstation - 060 ,002 - Class Data - Class 1 - all objects ms ( 1440709781944 ) <-AL-- outstation - 060 ,003 - Class Data - Class 2 - all objects ms ( 1440709781949 ) <-AL-- outstation - 060 ,004 - Class Data - Class 3 - all objects","title":"Logging"},{"location":"api/logging/#listening","text":"You can bind to the opendnp3 log stream by calling passing a shared_ptr<ILogHandler> into the DNP3Manager constructor. This interface just has a single method: class ILogHandler { public : virtual void Log ( const LogEntry & entry ) = 0 ; }; If you need to send log messages to more than one location, create your own proxy ILogHandler . Keep in mind that this is a callback from the thread-pool and will block that thread from executing. A good strategy for a file-logger in a big system would be to send a message to a worker thread to write the message to disk.","title":"Listening"},{"location":"api/logging/#individual-loggers","text":"Each channel and stack instance (master or outstation) has its own logger whose log level can be individually configured and adjusted at run-time. This allows you to increase the log level of a particular channel or stack, without receiving full protocol analysis for everything and grinding the system to a halt. You specify the initial log level for each channel when it is created and this is inherited by stacks on that channel. You can adjust it during execute by calling IChannel::SetLogFilters , IMaster::SetLogFilters , or IOutstation::SetLogFilters .","title":"Individual loggers"},{"location":"api/logging/#log-levels","text":"Opendnp3 defines a number of typical log levels like DEBUG, INFO, WARN, ERR. In addition it defines a number of log levels specific to the protocol dissection and analysis. Turning on all the various DNP3 analysis levels allows you to create useful communication traces like the following. ms ( 1440709781929 ) <-TL-- outstation - FIR: 1 FIN: 1 SEQ: 0 LEN: 11 ms ( 1440709781932 ) <-AL-- outstation - C0 15 3C 02 06 3C 03 06 3C 04 06 ms ( 1440709781934 ) <-AL-- outstation - FIR: 1 FIN: 1 CON: 0 UNS: 0 SEQ: 0 FUNC: DISABLE_UNSOLICITED ms ( 1440709781939 ) <-AL-- outstation - 060 ,002 - Class Data - Class 1 - all objects ms ( 1440709781944 ) <-AL-- outstation - 060 ,003 - Class Data - Class 2 - all objects ms ( 1440709781949 ) <-AL-- outstation - 060 ,004 - Class Data - Class 3 - all objects","title":"Log levels"},{"location":"api/masters/","text":"Creating a master A master in opendnp3 is a component that communicates with a single outstation via a communication channel. You may see this term used in other places to refer to a collection of such components communicating with multiple outstations. When more than one master is bound to a single communication channel, it is called a multi-drop configuration. This refers to the way in which an RS-485 serial network is chained from device to device. Opendnp3 will let you add multiple masters / outstations to any communication channel, regardless of he underlying transport. You could even bind a master to a TCP server and reverse the normal connection direction. To add a master to a communication channel you call the AddMaster(...) method on the channel interface: // Contains static configuration for the master, and transport/link layers MasterStackConfig stackConfig ; // you can optionally override these defaults like setting the application layer response timeout // or change behaviors on the master stackConfig . master . responseTimeout = TimeDuration :: Seconds ( 2 ); stackConfig . master . disableUnsolOnStartup = true ; // ... or you can override the default link layer settings stackConfig . link . LocalAddr = 1 ; stackConfig . link . RemoteAddr = 10 ; auto master = channel -> AddMaster ( \"master\" , // alias for logging PrintingSOEHandler :: Create (), // ISOEHandler (interface) asiodnp3 :: DefaultMasterApplication :: Create (), // IMasterApplication (interface) stackConfig // static stack configuration ); // enable the master - you can also Disable() it or Shutdown() permanently master -> Enable (); ISOEHandler Note the 2nd parameter in the call to AddMaster(...) . This is the user-defined interface used to receive measurement data that the master has received from the outstation. SOE stands for \"Sequence of Events\". SOE is a common term in SCADA circles that is synonymous with \"the order in which things happened\". class ISOEHandler : public ITransactable { public : virtual void Process ( const HeaderInfo & info , const ICollection < Indexed < Binary >>& values ) = 0 ; // more Process methods for types like Analog, Counter, etc .... } An ISOEHandler is just an interface with an overloaded Process method for every measurement type in DNP3. It also inherits Start() and End() methods from ITransactable . This allows you tell when the master begins and ends parsing a received ASDU that contains measurement data. You'll see this Start/End pattern with other interfaces in opendnp3. The PrintingSOEHandler in the snippet where we added the master is just a singleton that prints measurement values to the console. You'll definitely want to write your own implementation so that you can write to file, database, or display on your application in some fashion. The PrintingSOEHandler just extracts the measurement values from the ICollection like the following: void Process ( const HeaderInfo & info , const ICollection < Indexed < Binary >>& values ) { auto print = [] (const Indexed<Binary>& pair) { std : : cout << \" [ \" << pair.index << \" ] : \" << pair . value << std :: endl ; } ; values . ForeachItem ( print ); } There's also a wealth of information in the HeaderInfo object including: The specific group/variation associated with this ASDU header The QualifierCode associated with this header An enumeration describing the validity of the time-stamp for convenience to the programmer. The index of the header within the ASDU Important Remember that the callbacks for the ISOEHandler methods come from the thread-pool. Depending on the number of sessions, you may not want to block the stack in these callbacks. You might consider allocating some kind of object that is passed to a worker thread to actually write the data to disk/database. IMasterApplication The 3rd parameter in the call to AddMaster(...) is a user-defined interface called IMasterApplication . It inherits from two sub-interfaces ILinkListener and IUTCTimeSource as well as adding a number of methods that are master specific. You can see all the methods you can override in the code documentation, but the most important ones are: void IOnReceiveIIN(const IINField& iin) - Notifies you whenever an ASDU is received containing an internal indication field (IIN field). This allow you to log and react to specific error bits returned by the device. void OnTaskComplete(const TaskInfo& info) - Tell you about tasks that are built into the master succeeding/failing. This callback is usually used to assess the \"health\" of the session. The ILinkListener interface is also used on IOutstationApplication and is described in its own section . MasterStackConfig The final parameter passed into AddMaster(...) is a configuration struct that consists of link-layer configuration information and static configuration that defines the masters behavior. The link-layer config is also used for outstations, and is described in its own section . MasterParams Each of the dozen or so fields in this struct control certain automated behaviors within the master. Refer to the code documentation for complete descriptions. This struct controls behaviors like: The default response timeout Whether to perform unsolicited disable/enable on start-up Whether to perform automatic time synchronization if requested The maximum Tx/Rx ASDU size which always default to 2K as per the DNP3 specification IMaster When a master is added to a channel, the channel returns an IMaster interface. This interface provides all access to a number of operations on the master. Refer to the code documentation for specifics. Some examples are: Add periodic scans to the master like exception (Class 1/2/3) and integrity scans (Class 1/2/3/0) Scanning for specific ranges or event counts The ICommandProcessor sub-interface allow you to do SelectBeforeOperate and DirectOperate requests w/ CROBs and Analog Outputs ICommandProcessor This is a sub-interface that allows you to perform \"select-before-operate\" and \"direct operate\" commands. class ICommandProcessor { public : virtual void SelectAndOperate (... params ...) = 0 ; virtual void DirectOperate (... params ...) = 0 ; }; Opendnp3 supports multiple commands per request on both the master and the outstation, however, for convenience there are overloaded methods to issue a single command of each type . You can use these overloads or build a CommandSet , which is a collection of headers. CommandSet commands ; The easiest way to define headers is to use initializer_lists, but you can also create a specific header type and then add entries in a loop. // CROB to be sent to two indices ControlRelayOutputBlock crob ( ControlCode :: LATCH_ON ); // Use initializer list to create a header in a single call - Send LATCH_ON to indices 0 and 1 commands . Add < ControlRelayOutputBlock > ({ WithIndex ( crob , 0 ), WithIndex ( crob , 1 ) }); /// Add two analog outputs to the set using the header method. /// Note that the 'header' is captured as a reference. auto & header = commands . StartHeader < AnalogOutputInt16 > (); header . Add ( AnalogOutputInt16 ( 7 ), 3 ); header . Add ( AnalogOutputInt16 ( 9 ), 4 ); You pass the command set into the master using one of the ICommandProcessor methods. pMaster -> SelectAndOperate ( std :: move ( commands ), callback ); The callback is a lambda expression or std::function that accepts ICommandTaskResult as its single argument. auto callback = [] ( const ICommandTaskResult & result ) - > void { std : : cout << \"Summary: \" << TaskCompletionToString ( result . summary ) << std :: endl ; auto print = [] (const CommandPointResult& res) { std : : cout << \"Header: \" << res . headerIndex << \" Index: \" << res . index << \" State: \" << CommandPointStateToString ( res . state ) << \" Status: \" << CommandStatusToString ( res . status ); } ; result . ForeachItem ( print ); } ; The example above prints the summary value for the task, and information about the success or failure of each of the commands you specified in the CommandSet. Since we sent 4 individual command values, the handler would print something the following on a fully successful response: Summary: SUCCESS Header: 0 Index: 0 State: SUCCESS Status: SUCCESS Header: 0 Index: 1 State: SUCCESS Status: SUCCESS Header: 1 Index: 3 State: SUCCESS Status: SUCCESS Header: 1 Index: 4 State: SUCCESS Status: SUCCESS Imporant Even if the summary TaskCompletion value is SUCCESS, this doesn't mean that every command you sent was successful. It just means that the master got back some response that was parsed successfully. You must check the result for each command you sent individually. DNP3 allows for truncated responses if the outstation doesn't understand everything you sent. A possible response might be: Summary: SUCCESS Header: 0 Index: 0 State: SUCCESS Status: SUCCESS Header: 0 Index: 1 State: SUCCESS Status: SUCCESS Header: 1 Index: 3 State: SUCCESS Status: NOT_SUPPORTED Header: 1 Index: 4 State: INIT Status: UNDEFINED Note that you always get an entry for every command you specified, even if there's no response at all because the connection is down. Summary: FAILURE_NO_COMMS Header: 0 Index: 0 State: INIT Status: UNDEFINED Header: 0 Index: 1 State: INIT Status: UNDEFINED Header: 1 Index: 3 State: INIT Status: UNDEFINED Header: 1 Index: 4 State: INIT Status: UNDEFINED Refer to the Doxygen docs for detailed information about each enum type: TaskCompletion - The summary value for the task CommandPointState - The various result states for each command point. CommandStatus - The command status enumeration defined in the spec. Only valid for some states. Cleaning Up Calls to Shutdown() are idempotent. The master will be permanently deleted once all references to the shared_ptr<IMaster> have been dropped.","title":"Masters"},{"location":"api/masters/#creating-a-master","text":"A master in opendnp3 is a component that communicates with a single outstation via a communication channel. You may see this term used in other places to refer to a collection of such components communicating with multiple outstations. When more than one master is bound to a single communication channel, it is called a multi-drop configuration. This refers to the way in which an RS-485 serial network is chained from device to device. Opendnp3 will let you add multiple masters / outstations to any communication channel, regardless of he underlying transport. You could even bind a master to a TCP server and reverse the normal connection direction. To add a master to a communication channel you call the AddMaster(...) method on the channel interface: // Contains static configuration for the master, and transport/link layers MasterStackConfig stackConfig ; // you can optionally override these defaults like setting the application layer response timeout // or change behaviors on the master stackConfig . master . responseTimeout = TimeDuration :: Seconds ( 2 ); stackConfig . master . disableUnsolOnStartup = true ; // ... or you can override the default link layer settings stackConfig . link . LocalAddr = 1 ; stackConfig . link . RemoteAddr = 10 ; auto master = channel -> AddMaster ( \"master\" , // alias for logging PrintingSOEHandler :: Create (), // ISOEHandler (interface) asiodnp3 :: DefaultMasterApplication :: Create (), // IMasterApplication (interface) stackConfig // static stack configuration ); // enable the master - you can also Disable() it or Shutdown() permanently master -> Enable ();","title":"Creating a master"},{"location":"api/masters/#isoehandler","text":"Note the 2nd parameter in the call to AddMaster(...) . This is the user-defined interface used to receive measurement data that the master has received from the outstation. SOE stands for \"Sequence of Events\". SOE is a common term in SCADA circles that is synonymous with \"the order in which things happened\". class ISOEHandler : public ITransactable { public : virtual void Process ( const HeaderInfo & info , const ICollection < Indexed < Binary >>& values ) = 0 ; // more Process methods for types like Analog, Counter, etc .... } An ISOEHandler is just an interface with an overloaded Process method for every measurement type in DNP3. It also inherits Start() and End() methods from ITransactable . This allows you tell when the master begins and ends parsing a received ASDU that contains measurement data. You'll see this Start/End pattern with other interfaces in opendnp3. The PrintingSOEHandler in the snippet where we added the master is just a singleton that prints measurement values to the console. You'll definitely want to write your own implementation so that you can write to file, database, or display on your application in some fashion. The PrintingSOEHandler just extracts the measurement values from the ICollection like the following: void Process ( const HeaderInfo & info , const ICollection < Indexed < Binary >>& values ) { auto print = [] (const Indexed<Binary>& pair) { std : : cout << \" [ \" << pair.index << \" ] : \" << pair . value << std :: endl ; } ; values . ForeachItem ( print ); } There's also a wealth of information in the HeaderInfo object including: The specific group/variation associated with this ASDU header The QualifierCode associated with this header An enumeration describing the validity of the time-stamp for convenience to the programmer. The index of the header within the ASDU Important Remember that the callbacks for the ISOEHandler methods come from the thread-pool. Depending on the number of sessions, you may not want to block the stack in these callbacks. You might consider allocating some kind of object that is passed to a worker thread to actually write the data to disk/database.","title":"ISOEHandler"},{"location":"api/masters/#imasterapplication","text":"The 3rd parameter in the call to AddMaster(...) is a user-defined interface called IMasterApplication . It inherits from two sub-interfaces ILinkListener and IUTCTimeSource as well as adding a number of methods that are master specific. You can see all the methods you can override in the code documentation, but the most important ones are: void IOnReceiveIIN(const IINField& iin) - Notifies you whenever an ASDU is received containing an internal indication field (IIN field). This allow you to log and react to specific error bits returned by the device. void OnTaskComplete(const TaskInfo& info) - Tell you about tasks that are built into the master succeeding/failing. This callback is usually used to assess the \"health\" of the session. The ILinkListener interface is also used on IOutstationApplication and is described in its own section .","title":"IMasterApplication"},{"location":"api/masters/#masterstackconfig","text":"The final parameter passed into AddMaster(...) is a configuration struct that consists of link-layer configuration information and static configuration that defines the masters behavior. The link-layer config is also used for outstations, and is described in its own section .","title":"MasterStackConfig"},{"location":"api/masters/#masterparams","text":"Each of the dozen or so fields in this struct control certain automated behaviors within the master. Refer to the code documentation for complete descriptions. This struct controls behaviors like: The default response timeout Whether to perform unsolicited disable/enable on start-up Whether to perform automatic time synchronization if requested The maximum Tx/Rx ASDU size which always default to 2K as per the DNP3 specification","title":"MasterParams"},{"location":"api/masters/#imaster","text":"When a master is added to a channel, the channel returns an IMaster interface. This interface provides all access to a number of operations on the master. Refer to the code documentation for specifics. Some examples are: Add periodic scans to the master like exception (Class 1/2/3) and integrity scans (Class 1/2/3/0) Scanning for specific ranges or event counts The ICommandProcessor sub-interface allow you to do SelectBeforeOperate and DirectOperate requests w/ CROBs and Analog Outputs","title":"IMaster"},{"location":"api/masters/#icommandprocessor","text":"This is a sub-interface that allows you to perform \"select-before-operate\" and \"direct operate\" commands. class ICommandProcessor { public : virtual void SelectAndOperate (... params ...) = 0 ; virtual void DirectOperate (... params ...) = 0 ; }; Opendnp3 supports multiple commands per request on both the master and the outstation, however, for convenience there are overloaded methods to issue a single command of each type . You can use these overloads or build a CommandSet , which is a collection of headers. CommandSet commands ; The easiest way to define headers is to use initializer_lists, but you can also create a specific header type and then add entries in a loop. // CROB to be sent to two indices ControlRelayOutputBlock crob ( ControlCode :: LATCH_ON ); // Use initializer list to create a header in a single call - Send LATCH_ON to indices 0 and 1 commands . Add < ControlRelayOutputBlock > ({ WithIndex ( crob , 0 ), WithIndex ( crob , 1 ) }); /// Add two analog outputs to the set using the header method. /// Note that the 'header' is captured as a reference. auto & header = commands . StartHeader < AnalogOutputInt16 > (); header . Add ( AnalogOutputInt16 ( 7 ), 3 ); header . Add ( AnalogOutputInt16 ( 9 ), 4 ); You pass the command set into the master using one of the ICommandProcessor methods. pMaster -> SelectAndOperate ( std :: move ( commands ), callback ); The callback is a lambda expression or std::function that accepts ICommandTaskResult as its single argument. auto callback = [] ( const ICommandTaskResult & result ) - > void { std : : cout << \"Summary: \" << TaskCompletionToString ( result . summary ) << std :: endl ; auto print = [] (const CommandPointResult& res) { std : : cout << \"Header: \" << res . headerIndex << \" Index: \" << res . index << \" State: \" << CommandPointStateToString ( res . state ) << \" Status: \" << CommandStatusToString ( res . status ); } ; result . ForeachItem ( print ); } ; The example above prints the summary value for the task, and information about the success or failure of each of the commands you specified in the CommandSet. Since we sent 4 individual command values, the handler would print something the following on a fully successful response: Summary: SUCCESS Header: 0 Index: 0 State: SUCCESS Status: SUCCESS Header: 0 Index: 1 State: SUCCESS Status: SUCCESS Header: 1 Index: 3 State: SUCCESS Status: SUCCESS Header: 1 Index: 4 State: SUCCESS Status: SUCCESS Imporant Even if the summary TaskCompletion value is SUCCESS, this doesn't mean that every command you sent was successful. It just means that the master got back some response that was parsed successfully. You must check the result for each command you sent individually. DNP3 allows for truncated responses if the outstation doesn't understand everything you sent. A possible response might be: Summary: SUCCESS Header: 0 Index: 0 State: SUCCESS Status: SUCCESS Header: 0 Index: 1 State: SUCCESS Status: SUCCESS Header: 1 Index: 3 State: SUCCESS Status: NOT_SUPPORTED Header: 1 Index: 4 State: INIT Status: UNDEFINED Note that you always get an entry for every command you specified, even if there's no response at all because the connection is down. Summary: FAILURE_NO_COMMS Header: 0 Index: 0 State: INIT Status: UNDEFINED Header: 0 Index: 1 State: INIT Status: UNDEFINED Header: 1 Index: 3 State: INIT Status: UNDEFINED Header: 1 Index: 4 State: INIT Status: UNDEFINED Refer to the Doxygen docs for detailed information about each enum type: TaskCompletion - The summary value for the task CommandPointState - The various result states for each command point. CommandStatus - The command status enumeration defined in the spec. Only valid for some states.","title":"ICommandProcessor"},{"location":"api/masters/#cleaning-up","text":"Calls to Shutdown() are idempotent. The master will be permanently deleted once all references to the shared_ptr<IMaster> have been dropped.","title":"Cleaning Up"},{"location":"api/outstations/","text":"An outstation in opendnp3 is a component that communicates with a single master via a communication channel. It makes measurements of the physical world and then sends them to a master upon request (solicited) or on its own accord (unsolicited). Occasionally a master requests that it do something by sending it a control. Just like a master, an outstation can be attached to any communication channel that opendnp3 supports. To add an outstation to a communication channel you call the AddOutstation method on the channel interface: OutstationStackConfig stackConfig ; // You must specify the shape of your database and the size of the event buffers stackConfig . dbTemplate = DatabaseTemplate :: AllTypes ( 10 ); stackConfig . outstation . eventBufferConfig = EventBufferConfig :: AllTypes ( 10 ); // you can override a default outstation parameters here stackConfig . outstation . params . allowUnsolicited = true ; // You can override the default link layer settings here // in this example we've changed the default link layer addressing stackConfig . link . LocalAddr = 10 ; stackConfig . link . RemoteAddr = 1 ; auto outstation = channel -> AddOutstation ( \"outstation\" , // alias for logging SuccessCommandHandler :: Create (), // ICommandHandler (interface) DefaultOutstationApplication :: Create (), // IOutstationApplication (interface) stackConfig // static stack configuration ); outstation -> Enable (); UpdateBuilder When a new measurement is read from an input or a new value is received from a downstream protocol, you need to update the corresponding value in the outstation. This is accomplished with the UpdateBuilder and corresponding Updates class. UpdateBuilder builder ; builder . Update ( Counter ( state . count ), 0 ); builder . Update ( Analog ( state . value ), 0 ); // ... update more types and indices // finalize the set of updates auto updates = builder . Build (); // apply the updates to one or more outstations outstation -> apply ( updates ); The update is atomic. All of the updated values are applied to the outstation database and event buffers at the same time. The Updates instance returned from UpdateBuilder::Build() can be safely sent to any number of outstation instances. The outstation automatically decides if these updates produce events. How events are detected are defined within the DNP3 standard, and varies from type to type. Analogs and counters can use deadbands to ensure that unimportant changes are not reported. ICommandHandler When the outstation receives a control request, it dispatches individual commands in the message to the ICommandhandler interface supplied when the outstation was added to the channel. class ICommandHandler : public ITransactable { virtual CommandStatus Select ( const ControlRelayOutputBlock & command , uint16_t index ) = 0 ; virtual CommandStatus Operate ( const ControlRelayOutputBlock & command , uint16_t index , OperateType opType ) = 0 ; /// ... additional methods for the 4 types of analog outputs - Group 41Var[1-4] } You'll notice that the interface inherits from ITransactable meaning that it has Start()/End() methods just like the ISOEHandler interface in the master. ASDUs can contain multiple controls in a single object header, and possibly multiple headers. The Start()/End() methods tell you when an ASDU containing commands begins and ends. Many applications probably don't care, but this knowledge is there if you need it for some reason. The Select method shouldn't actually perform the command. Think of it as a question along the lines of \"Is this operation supported?\" . Select-Before-Operate (SBO) is an artifact of the days before the SCADA community really trusted CRCs. It's a 2-pass control scheme where the outstation verifies that the select/operate are identical. It was intended as an additional protection against data corruption on noisy networks. The Operate method is called from a successful SBO sequence or from a DirectOperate or DirectOperateNoAck request. Applications shouldn't care how the request came in, but the OperateType parameter provides an enumeration that can be used to reject certain operations or to forward the same mode downstream in gateway applications. enum class OperateType : uint8_t { /// The outstation received a valid prior SELECT followed by OPERATE SelectBeforeOperate = 0x0 , /// The outstation received a direct operate request DirectOperate = 0x1 , /// The outstation received a direct operate no ack request DirectOperateNoAck = 0x2 }; CommandStatus You must immediately return a CommandStatus enumeration value in response to each callback. This callback should never block . enum class CommandStatus : uint8_t { /// command was accepted, initiated, or queued SUCCESS = 0 , /// command timed out before completing TIMEOUT = 1 , /// command requires being selected before operate, configuration issue NO_SELECT = 2 , /// more values ... } The enumeration contains about ~18 different values, and you should refer to 1815 or the code comments for a description of each. In general, you'll be choosing SUCCESS or some kind of error code. It's important to understand that SUCCESS doesn't imply that the command was synchronously executed. It really just means that the command was received and queued. Some devices can synchronously process a command, e.g. quickly writing to memory mapped I/O, but you'd never want to block in a gateway application to perform a downstream Modbus transaction. You'd pass the control of to another thread or queue the operation in some way for subsequent processing.","title":"Outstations"},{"location":"api/outstations/#updatebuilder","text":"When a new measurement is read from an input or a new value is received from a downstream protocol, you need to update the corresponding value in the outstation. This is accomplished with the UpdateBuilder and corresponding Updates class. UpdateBuilder builder ; builder . Update ( Counter ( state . count ), 0 ); builder . Update ( Analog ( state . value ), 0 ); // ... update more types and indices // finalize the set of updates auto updates = builder . Build (); // apply the updates to one or more outstations outstation -> apply ( updates ); The update is atomic. All of the updated values are applied to the outstation database and event buffers at the same time. The Updates instance returned from UpdateBuilder::Build() can be safely sent to any number of outstation instances. The outstation automatically decides if these updates produce events. How events are detected are defined within the DNP3 standard, and varies from type to type. Analogs and counters can use deadbands to ensure that unimportant changes are not reported.","title":"UpdateBuilder"},{"location":"api/outstations/#icommandhandler","text":"When the outstation receives a control request, it dispatches individual commands in the message to the ICommandhandler interface supplied when the outstation was added to the channel. class ICommandHandler : public ITransactable { virtual CommandStatus Select ( const ControlRelayOutputBlock & command , uint16_t index ) = 0 ; virtual CommandStatus Operate ( const ControlRelayOutputBlock & command , uint16_t index , OperateType opType ) = 0 ; /// ... additional methods for the 4 types of analog outputs - Group 41Var[1-4] } You'll notice that the interface inherits from ITransactable meaning that it has Start()/End() methods just like the ISOEHandler interface in the master. ASDUs can contain multiple controls in a single object header, and possibly multiple headers. The Start()/End() methods tell you when an ASDU containing commands begins and ends. Many applications probably don't care, but this knowledge is there if you need it for some reason. The Select method shouldn't actually perform the command. Think of it as a question along the lines of \"Is this operation supported?\" . Select-Before-Operate (SBO) is an artifact of the days before the SCADA community really trusted CRCs. It's a 2-pass control scheme where the outstation verifies that the select/operate are identical. It was intended as an additional protection against data corruption on noisy networks. The Operate method is called from a successful SBO sequence or from a DirectOperate or DirectOperateNoAck request. Applications shouldn't care how the request came in, but the OperateType parameter provides an enumeration that can be used to reject certain operations or to forward the same mode downstream in gateway applications. enum class OperateType : uint8_t { /// The outstation received a valid prior SELECT followed by OPERATE SelectBeforeOperate = 0x0 , /// The outstation received a direct operate request DirectOperate = 0x1 , /// The outstation received a direct operate no ack request DirectOperateNoAck = 0x2 };","title":"ICommandHandler"},{"location":"api/outstations/#commandstatus","text":"You must immediately return a CommandStatus enumeration value in response to each callback. This callback should never block . enum class CommandStatus : uint8_t { /// command was accepted, initiated, or queued SUCCESS = 0 , /// command timed out before completing TIMEOUT = 1 , /// command requires being selected before operate, configuration issue NO_SELECT = 2 , /// more values ... } The enumeration contains about ~18 different values, and you should refer to 1815 or the code comments for a description of each. In general, you'll be choosing SUCCESS or some kind of error code. It's important to understand that SUCCESS doesn't imply that the command was synchronously executed. It really just means that the command was received and queued. Some devices can synchronously process a command, e.g. quickly writing to memory mapped I/O, but you'd never want to block in a gateway application to perform a downstream Modbus transaction. You'd pass the control of to another thread or queue the operation in some way for subsequent processing.","title":"CommandStatus"},{"location":"api/tls/","text":"Transport Layer Security (TLS) TLS support provides two additional channel types: TLSServer and TLSClient. These overloaded methods on DNP3Manager take an additional configuration structure called TLSConfig . The opendnp3 TLS implementation only allows mutually authenticated connections using client certificates. Each side must provide 3 items: A certificate (either self-signed or root certificate) that will be used to authenticate the peer certificate. A local certificate to send to the peer. A private key corresponding to the public key in the local certificate used to authenticate. All keys and certificates should be provided in the PEM format.","title":"TLS Support"},{"location":"api/tls/#transport-layer-security-tls","text":"TLS support provides two additional channel types: TLSServer and TLSClient. These overloaded methods on DNP3Manager take an additional configuration structure called TLSConfig . The opendnp3 TLS implementation only allows mutually authenticated connections using client certificates. Each side must provide 3 items: A certificate (either self-signed or root certificate) that will be used to authenticate the peer certificate. A local certificate to send to the peer. A private key corresponding to the public key in the local certificate used to authenticate. All keys and certificates should be provided in the PEM format.","title":"Transport Layer Security (TLS)"},{"location":"build/cmake/","text":"CMake Opendnp3 uses a build system generator called CMake . This means that the actual build files (e.g. a Makefile or Visual Studio .SLN) are generated from a artifact. This allows the opendnp3 project to maintain a single project file for all platforms, minimizing per-platform maintenance. CMake also integrates nicely with C++ IDEs like KDevelop or CLion . Optional Components By default, CMake will not build tests, demos, or TLS support. You can enable each optional component individually by specifying them on the command line: > cmake ../dnp3 -D<option> = ON Option Name Comments DNP3_ALL build all optional components below DNP3_DEMO build the example programs DNP3_DOTNET build the .NET bindings (Windows only) DNP3_JAVA build the java bindings DNP3_TEST build the unit test suites DNP3_TLS build support for TLS channels (requires openssl) DNP3_DECODER build the decoder module DNP3_FUZZING build Google OSS-Fuzz integration For example, to build the demos including TLS support: > cmake ../dnp3 -DDNP3_DEMO = ON -DDNP3_TLS = ON Build Options Most of command-line options you can feed to CMake to generate your build environment are platform-independent. This documentation can't tell you everything that CMake can do. We only document some of the more common flags here for your convenience. All of the following examples assume an out-of-source build folder in a sibling directory to the opendnp3 distribution. Static vs Dynamic Linking You can switch between building static or dynamic linking using the STATICLIBS flag. Note that this flag is provided by the project and is not a CMake flag. On Windows, static libs are the default. On Linux, dynamic libs are the default. > cmake ../dnp3 STATICLIBS=ON # build static libraries > cmake ../dnp3 STATICLIBS=OFF # build dynamic libraries Debug vs Release You can configure release vs debug builds using the CMAKE_BUILD_TYPE flag. Note that on Windows, the generated SLN contains debug and release build targets already > cmake ../dnp3 -DCMAKE_BUILD_TYPE = Debug > cmake ../dnp3 -DCMAKE_BUILD_TYPE = Release Non-default generators By default, CMake will pick a generator to use if you don't tell it which one. You can see a list of all available generators using the help flag. > cmake --help You can then specify a specific generator, e.g. to do a full 64-bit build on Windows: > mkdir build64 > cmake .. -DDNP3_ALL = ON -G \"Visual Studio 14 2015 Win64\" Setting the install prefix If the default install location isn't where you want it to be, you can configure it using CMAKE_INSTALL_PREFIX . On Debian-based systems this should probably be: > cmake .. -DCMAKE_INSTALL_PREFIX = /usr/lib On windows, you might put your libraries and headers somewhere like: > cmake .. -DCMAKE_INSTALL_PREFIX = C: \\l ibs \\o pendnp3 Locating ASIO The included sub-folder of the ASIO distribution (the folder that contains 'asio.hpp') needs to be on your include path, but there are several ways you can do this. You can choose the option that makes the most sense your particular build environment. CMake will try the following things in order to locate your ASIO. 1) Look to see if you checked out ASIO as a git submodule when cloning opendnp3 > git clone --recursive https://github.com/automatak/dnp3.git 2) look to see if the variable ASIO_HOME was defined via the cmake command line. > cmake ../dnp3 -DASIO_HOME = C:/libs/asio-asio-1-12-2/asio/include 3) Check if ASIO_HOME is defined as an environment variable. For instance, on Windows you might define your environment variable to look like this. ASIO_HOME = C:/libs/asio-asio-1-12-2/asio/include On Ubuntu Linux, you might add a line to ~/.bashrc as follows: export ASIO_HOME = ~/asio-asio-1-12-2/asio/include Tip If CMake can't find ASIO using one of the mechanisms above, it will just assume the headers are installed on the system. No checks are performed, so the build will fail is this isn't true","title":"CMake"},{"location":"build/cmake/#cmake","text":"Opendnp3 uses a build system generator called CMake . This means that the actual build files (e.g. a Makefile or Visual Studio .SLN) are generated from a artifact. This allows the opendnp3 project to maintain a single project file for all platforms, minimizing per-platform maintenance. CMake also integrates nicely with C++ IDEs like KDevelop or CLion .","title":"CMake"},{"location":"build/cmake/#optional-components","text":"By default, CMake will not build tests, demos, or TLS support. You can enable each optional component individually by specifying them on the command line: > cmake ../dnp3 -D<option> = ON Option Name Comments DNP3_ALL build all optional components below DNP3_DEMO build the example programs DNP3_DOTNET build the .NET bindings (Windows only) DNP3_JAVA build the java bindings DNP3_TEST build the unit test suites DNP3_TLS build support for TLS channels (requires openssl) DNP3_DECODER build the decoder module DNP3_FUZZING build Google OSS-Fuzz integration For example, to build the demos including TLS support: > cmake ../dnp3 -DDNP3_DEMO = ON -DDNP3_TLS = ON","title":"Optional Components"},{"location":"build/cmake/#build-options","text":"Most of command-line options you can feed to CMake to generate your build environment are platform-independent. This documentation can't tell you everything that CMake can do. We only document some of the more common flags here for your convenience. All of the following examples assume an out-of-source build folder in a sibling directory to the opendnp3 distribution.","title":"Build Options"},{"location":"build/cmake/#static-vs-dynamic-linking","text":"You can switch between building static or dynamic linking using the STATICLIBS flag. Note that this flag is provided by the project and is not a CMake flag. On Windows, static libs are the default. On Linux, dynamic libs are the default. > cmake ../dnp3 STATICLIBS=ON # build static libraries > cmake ../dnp3 STATICLIBS=OFF # build dynamic libraries","title":"Static vs Dynamic Linking"},{"location":"build/cmake/#debug-vs-release","text":"You can configure release vs debug builds using the CMAKE_BUILD_TYPE flag. Note that on Windows, the generated SLN contains debug and release build targets already > cmake ../dnp3 -DCMAKE_BUILD_TYPE = Debug > cmake ../dnp3 -DCMAKE_BUILD_TYPE = Release","title":"Debug vs Release"},{"location":"build/cmake/#non-default-generators","text":"By default, CMake will pick a generator to use if you don't tell it which one. You can see a list of all available generators using the help flag. > cmake --help You can then specify a specific generator, e.g. to do a full 64-bit build on Windows: > mkdir build64 > cmake .. -DDNP3_ALL = ON -G \"Visual Studio 14 2015 Win64\"","title":"Non-default generators"},{"location":"build/cmake/#setting-the-install-prefix","text":"If the default install location isn't where you want it to be, you can configure it using CMAKE_INSTALL_PREFIX . On Debian-based systems this should probably be: > cmake .. -DCMAKE_INSTALL_PREFIX = /usr/lib On windows, you might put your libraries and headers somewhere like: > cmake .. -DCMAKE_INSTALL_PREFIX = C: \\l ibs \\o pendnp3","title":"Setting the install prefix"},{"location":"build/cmake/#locating-asio","text":"The included sub-folder of the ASIO distribution (the folder that contains 'asio.hpp') needs to be on your include path, but there are several ways you can do this. You can choose the option that makes the most sense your particular build environment. CMake will try the following things in order to locate your ASIO. 1) Look to see if you checked out ASIO as a git submodule when cloning opendnp3 > git clone --recursive https://github.com/automatak/dnp3.git 2) look to see if the variable ASIO_HOME was defined via the cmake command line. > cmake ../dnp3 -DASIO_HOME = C:/libs/asio-asio-1-12-2/asio/include 3) Check if ASIO_HOME is defined as an environment variable. For instance, on Windows you might define your environment variable to look like this. ASIO_HOME = C:/libs/asio-asio-1-12-2/asio/include On Ubuntu Linux, you might add a line to ~/.bashrc as follows: export ASIO_HOME = ~/asio-asio-1-12-2/asio/include Tip If CMake can't find ASIO using one of the mechanisms above, it will just assume the headers are installed on the system. No checks are performed, so the build will fail is this isn't true","title":"Locating ASIO"},{"location":"build/java/","text":"The Java bindings are built as two separate pieces: standard JAR file native shared library built from the C++ source Important Java 1.8 or greater is required because of features used in Java bindings Building the C++ bindings Use the '-DDNP3_JAVA=ON' option when configuring CMake. CMake will locate your JNI headers using the JAVA_HOME environment variable. The shared library must be installed in a system location or the path specified using the system.library.path JVM option. Building the JAR The java library is built and installed locally using Maven. > cd java > mvn install You can now use it in your Maven based Java projects using <dependencies> ... <dependency> <groupId> com.automatak.dnp3 </groupId> <artifactId> opendnp3-bindings </artifactId> <version> ${opendnp3.version} </version> </dependency> ... </dependencies>","title":"Java"},{"location":"build/java/#building-the-c-bindings","text":"Use the '-DDNP3_JAVA=ON' option when configuring CMake. CMake will locate your JNI headers using the JAVA_HOME environment variable. The shared library must be installed in a system location or the path specified using the system.library.path JVM option.","title":"Building the C++ bindings"},{"location":"build/java/#building-the-jar","text":"The java library is built and installed locally using Maven. > cd java > mvn install You can now use it in your Maven based Java projects using <dependencies> ... <dependency> <groupId> com.automatak.dnp3 </groupId> <artifactId> opendnp3-bindings </artifactId> <version> ${opendnp3.version} </version> </dependency> ... </dependencies>","title":"Building the JAR"},{"location":"build/libraries/","text":"Libraries An overview of the directory structure is presented here. It describes only the most important elements, and is not an exhaustive list of every folder in the project. # C++ projects built using CMake /cpp /libs /include /openpal // interfaces, containers, and parsers ( Platform Abstraction Layer ) /opendnp3 // the core dnp3 library w/ no external dependencies other than openpal /asiopal // provides ASIO-based implementations of things in openpal /asiodnp3 // high-level dnp3 interface that leverages asiopal and opendnp3 /dnp3decode // a dnp3 decoder based on the opendnp3 parsers The dependencies between the libraries for linking purposes can be defined as: opendnp3 -> { openpal } asiopal -> { openpal } asiodnp3 -> { opendnp3, asiopal, openpal } When building an external application on Linux for instance, you need to link against all four libraries: -lasiodnp3 -lasiopal -lopendnp3 -lopenpal CLR Bindings # CLR bindings built using CMake /dotnet /CLRInterface // Pure CLR interfaces and classes that comprise the API /CLRAdapter // a C++/CLI project that adapts the underlying C++ libraries to C# /examples // C# example applications Java Bindings # Java bindings built using CMake (native) and Maven (pom.xml) /java /bindings // Java w/ native stubs /codegen // Code generator written in Scala that generates C++ JNI boilerplate /cpp // C++ compiled to libopendnp3java.dll/so /example // Java example programs that depend on api/bindings Jars","title":"Libraries"},{"location":"build/libraries/#libraries","text":"An overview of the directory structure is presented here. It describes only the most important elements, and is not an exhaustive list of every folder in the project. # C++ projects built using CMake /cpp /libs /include /openpal // interfaces, containers, and parsers ( Platform Abstraction Layer ) /opendnp3 // the core dnp3 library w/ no external dependencies other than openpal /asiopal // provides ASIO-based implementations of things in openpal /asiodnp3 // high-level dnp3 interface that leverages asiopal and opendnp3 /dnp3decode // a dnp3 decoder based on the opendnp3 parsers The dependencies between the libraries for linking purposes can be defined as: opendnp3 -> { openpal } asiopal -> { openpal } asiodnp3 -> { opendnp3, asiopal, openpal } When building an external application on Linux for instance, you need to link against all four libraries: -lasiodnp3 -lasiopal -lopendnp3 -lopenpal","title":"Libraries"},{"location":"build/libraries/#clr-bindings","text":"# CLR bindings built using CMake /dotnet /CLRInterface // Pure CLR interfaces and classes that comprise the API /CLRAdapter // a C++/CLI project that adapts the underlying C++ libraries to C# /examples // C# example applications","title":"CLR Bindings"},{"location":"build/libraries/#java-bindings","text":"# Java bindings built using CMake (native) and Maven (pom.xml) /java /bindings // Java w/ native stubs /codegen // Code generator written in Scala that generates C++ JNI boilerplate /cpp // C++ compiled to libopendnp3java.dll/so /example // Java example programs that depend on api/bindings Jars","title":"Java Bindings"},{"location":"build/linux/","text":"On linux, the easiest way to use CMake is just to let it create a makefile for you. You can then use this makefile in the same way you normally would: > mkdir build ; cd build > cmake .. <options> > make -j > sudo make install Cross-compiling CMake also supports cross-compiling to embedded-linux platforms. How to do this is outside the scope of this documentation, but is explained here . The preferred method is to create a toolchain file for each target platform. An example integration on a TI MSP432 is available here , although it's quite old.","title":"Linux"},{"location":"build/linux/#cross-compiling","text":"CMake also supports cross-compiling to embedded-linux platforms. How to do this is outside the scope of this documentation, but is explained here . The preferred method is to create a toolchain file for each target platform. An example integration on a TI MSP432 is available here , although it's quite old.","title":"Cross-compiling"},{"location":"build/requirements/","text":"Platforms Opendnp3 is a cross-platform C++ library. It targets all major operating systems including Linux, Windows, and OSX. C++14 Opendnp3 uses the following C++11/14 features: std::unique_ptr & std::shared_ptr (including std::make_unique , part of C++14) - smart pointers are used for automatic memory management std::thread - platform-independent threading used to manage the thread pool std::chrono - platform-independent time operations including steady-clock used to manage timers variadic templates - used to simplify parsing routines. ASIO ASIO is a header-only library that provides asynchronous I/O (ASIO). Opendnp3 uses ASIO for several things. Cross-platform sockets Cross-platform serial ports A multi-core event loop Abstract timers on top of std::chrono Info OpenDNP3 is currently using ASIO v1.12.2 Compilers The following compilers are known to work, and are tested frequently. MSVC++ - Visual Studio >= 2015 g++ >= 4.9.x clang >= 3.5","title":"Requirements"},{"location":"build/requirements/#platforms","text":"Opendnp3 is a cross-platform C++ library. It targets all major operating systems including Linux, Windows, and OSX.","title":"Platforms"},{"location":"build/requirements/#c14","text":"Opendnp3 uses the following C++11/14 features: std::unique_ptr & std::shared_ptr (including std::make_unique , part of C++14) - smart pointers are used for automatic memory management std::thread - platform-independent threading used to manage the thread pool std::chrono - platform-independent time operations including steady-clock used to manage timers variadic templates - used to simplify parsing routines.","title":"C++14"},{"location":"build/requirements/#asio","text":"ASIO is a header-only library that provides asynchronous I/O (ASIO). Opendnp3 uses ASIO for several things. Cross-platform sockets Cross-platform serial ports A multi-core event loop Abstract timers on top of std::chrono Info OpenDNP3 is currently using ASIO v1.12.2","title":"ASIO"},{"location":"build/requirements/#compilers","text":"The following compilers are known to work, and are tested frequently. MSVC++ - Visual Studio >= 2015 g++ >= 4.9.x clang >= 3.5","title":"Compilers"},{"location":"build/windows/","text":"On Windows, CMake is used to generate a Visual Studio Solution (SLN) and associated project files. > mkdir build ; cd build > cmake .. <options> Once you've generated your SLN, you can just open it and use Visual Studio to build the project for you just like any other project. Command Line Alternatively, you can just invoke msbuild.exe on the generated solution and build from the command line. > msbuild opendnp3.sln or > cmake --build . Installing CMake creates a special project called \"install\" that you can run inside Visual Studio to install the headers and libraries to the directory specified by CMAKE_INSTALL_PREFIX . TLS Support If you need to build the stack w/ TLS support (or you're using the .NET bindings), then you need to install OpenSSL on Windows. Use the installers from ShiningLight . .NET Bindings By far, the easiest way to use the .NET bindings is just to install the Nuget package we publish: PM> Install-Package opendnp3 or to allow pre-release versions: PM> Install-Package opendnp3 -Pre Building Enable the building of the .NET bindings when configuring CMake, e.g.: > cmake .. -DDNP3_DOTNET=ON","title":"Windows"},{"location":"build/windows/#command-line","text":"Alternatively, you can just invoke msbuild.exe on the generated solution and build from the command line. > msbuild opendnp3.sln or > cmake --build .","title":"Command Line"},{"location":"build/windows/#installing","text":"CMake creates a special project called \"install\" that you can run inside Visual Studio to install the headers and libraries to the directory specified by CMAKE_INSTALL_PREFIX .","title":"Installing"},{"location":"build/windows/#tls-support","text":"If you need to build the stack w/ TLS support (or you're using the .NET bindings), then you need to install OpenSSL on Windows. Use the installers from ShiningLight .","title":"TLS Support"},{"location":"build/windows/#net-bindings","text":"By far, the easiest way to use the .NET bindings is just to install the Nuget package we publish: PM> Install-Package opendnp3 or to allow pre-release versions: PM> Install-Package opendnp3 -Pre","title":".NET Bindings"},{"location":"build/windows/#building","text":"Enable the building of the .NET bindings when configuring CMake, e.g.: > cmake .. -DDNP3_DOTNET=ON","title":"Building"},{"location":"features/features/","text":"Performance Opendnp3 is engineered to perform exceptionally well for large systems with hundreds or even thousands of concurrent sessions: The protocol stack uses non-blocking I/O and runs on a thread-pool. This makes it extremely memory and CPU efficient at scale. Zero-copy / zero-allocation parsing. When parsing an application layer message, the parser doesn't create a full object model representation of the message. This makes the processing of requests extremely fast and efficient. Robustness & Security The principal developers who work on opendnp3 have lead the charge in the industry in terms of security testing DNP3 . You won't find a more reliable implementation of the protocol anywhere. Our commitment to a high-quality project is evident in what we do. An exhaustive unit test suite in excess of 80% coverage Fuzzing using the Aegis fuzzer and Google's OSS Fuzz Static analysis using tools like Coverity and cppcheck We provide integrated TLS support that makes opendnp3 an ideal solution for integrating with real-time markets programs like PJM Jetstream . Compliance IEEE-1815 defines 4 subset levels (1-4) that consist of the objects and function codes that must be supported by the master and outstation. A device profile template that describes the supported objects and function codes can be found here . Conformance tests only exist for subset levels 1 & 2. Opendnp3 is routinely tested for subset level 2 using 3rd party tools, but you can also configure the library to act as a simple level 1 device. The stack currently meets all the level 2 subset requirements with the notable except of support BROADCAST messages. Subset Levels 1-4 Level Support Missing Features 1 FULL 2 FULL 3 FULL 4 PARTIAL Analog dead-bands (group 34), device attributes (group 0), command events (groups 13 & 43) Subset Level 4+ Feature Support Comment Octet strings (group 110/11) FULL Empty strings not allowed Virtual Terminal NONE Secure Authentication NONE Use TLS. See this paper for more details File Transfer NONE Datasets NONE If your integration requires some functionality not currently implemented, consider sponsoring the additions.","title":"Features"},{"location":"features/features/#performance","text":"Opendnp3 is engineered to perform exceptionally well for large systems with hundreds or even thousands of concurrent sessions: The protocol stack uses non-blocking I/O and runs on a thread-pool. This makes it extremely memory and CPU efficient at scale. Zero-copy / zero-allocation parsing. When parsing an application layer message, the parser doesn't create a full object model representation of the message. This makes the processing of requests extremely fast and efficient.","title":"Performance"},{"location":"features/features/#robustness-security","text":"The principal developers who work on opendnp3 have lead the charge in the industry in terms of security testing DNP3 . You won't find a more reliable implementation of the protocol anywhere. Our commitment to a high-quality project is evident in what we do. An exhaustive unit test suite in excess of 80% coverage Fuzzing using the Aegis fuzzer and Google's OSS Fuzz Static analysis using tools like Coverity and cppcheck We provide integrated TLS support that makes opendnp3 an ideal solution for integrating with real-time markets programs like PJM Jetstream .","title":"Robustness &amp; Security"},{"location":"features/features/#compliance","text":"IEEE-1815 defines 4 subset levels (1-4) that consist of the objects and function codes that must be supported by the master and outstation. A device profile template that describes the supported objects and function codes can be found here . Conformance tests only exist for subset levels 1 & 2. Opendnp3 is routinely tested for subset level 2 using 3rd party tools, but you can also configure the library to act as a simple level 1 device. The stack currently meets all the level 2 subset requirements with the notable except of support BROADCAST messages.","title":"Compliance"},{"location":"features/features/#subset-levels-1-4","text":"Level Support Missing Features 1 FULL 2 FULL 3 FULL 4 PARTIAL Analog dead-bands (group 34), device attributes (group 0), command events (groups 13 & 43)","title":"Subset Levels 1-4"},{"location":"features/features/#subset-level-4","text":"Feature Support Comment Octet strings (group 110/11) FULL Empty strings not allowed Virtual Terminal NONE Secure Authentication NONE Use TLS. See this paper for more details File Transfer NONE Datasets NONE If your integration requires some functionality not currently implemented, consider sponsoring the additions.","title":"Subset Level 4+"},{"location":"troubleshooting/troubleshooting/","text":"This section serves as a FAQ for common issues and their resolutions. Unable to find asio.hpp You need to tell CMake where the ASIO headers are located. Please review the CMake instructions . Unable to load DNP3CLRAdapter or one of its dependencies .NET does not provide useful error messages when an assembly can't find a native dependency. The .NET bindings depend on the Visual C++ Runtime library for the version of Visual Studio you used to build them. These packages can be found from Microsoft by searching for \"Visual Studio C++ Runtime\" in your favorite search engine. You might also see this error because CLRAdapter can't find openssl (libeay32.dll / libssl32.dll) if your bindings didn't have these linked statically. The solution is to make sure openssl is installed in the correct system location. Master or Outstation doesn't detect an ethernet cable being unplugged There is no way through the standard socket API to detect this, other than trying to write data to the socket. This means that if master or outstation sessions are quiescent (meaning that they don't write data periodically), you should be using the link-layer keep-alive feature to ensure that dead/hung connections are appropriately detected.","title":"Troubleshooting"},{"location":"troubleshooting/troubleshooting/#unable-to-find-asiohpp","text":"You need to tell CMake where the ASIO headers are located. Please review the CMake instructions .","title":"Unable to find asio.hpp"},{"location":"troubleshooting/troubleshooting/#unable-to-load-dnp3clradapter-or-one-of-its-dependencies","text":".NET does not provide useful error messages when an assembly can't find a native dependency. The .NET bindings depend on the Visual C++ Runtime library for the version of Visual Studio you used to build them. These packages can be found from Microsoft by searching for \"Visual Studio C++ Runtime\" in your favorite search engine. You might also see this error because CLRAdapter can't find openssl (libeay32.dll / libssl32.dll) if your bindings didn't have these linked statically. The solution is to make sure openssl is installed in the correct system location.","title":"Unable to load DNP3CLRAdapter or one of its dependencies"},{"location":"troubleshooting/troubleshooting/#master-or-outstation-doesnt-detect-an-ethernet-cable-being-unplugged","text":"There is no way through the standard socket API to detect this, other than trying to write data to the socket. This means that if master or outstation sessions are quiescent (meaning that they don't write data periodically), you should be using the link-layer keep-alive feature to ensure that dead/hung connections are appropriately detected.","title":"Master or Outstation doesn't detect an ethernet cable being unplugged"}]}